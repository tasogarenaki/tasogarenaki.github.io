[
  
  {
    "title": "CS61B Note",
    "url": "/posts/CS61B-Note/",
    "categories": "Note, CS",
    "tags": "note, java, cs61b",
    "date": "2022-08-30 18:00:00 +0000",
    





    "snippet": "1 Introduction      Set the course code                  Create a repository from GitHub                    Create a folder A on local                    $ cd A$ git clone https://github.com/my_repository.git$ cd B (Folder inside A)$ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git$ git pull skeleton master                    Move the HelloWorld.java and HelloNumbers.java that you previously created into the lab1directory.                    $ git add lab1/*$ git commit -m &quot;completed first part of lab1&quot;$ git push origin master                          IntelliJ IDEA (Every Time!)          Open - Choose the project file (not CS61B)      File - Project Structure - Libraries - + - Java - CS61B/library-sp18/javalib - OK - OK      File - New Projects Setup - Structure - Project - SDK: choose one - OK - open a file - Setup SDK        Debugger          Breakpoints (right click for the breakpoint conditional)      Stepping over: step by step      Stepping into: get into the method      Stepping out: get out of the method      Resume            Some key syntactic features:                  public class: all code lives inside of classes.                    The code that is run is inside of a method called main, which is declared as public static void main(String[] args).                  void: It has no return type.          main: This is the name of the method.          String[] args: This is a parameter that is passed to the main method.                    Use { and } to denote the beginning and the end of a section of code.      Statements must end with semi-colons ;.      Comments with /* */ or //.      Javadoc: /** */ for methods or classes.              Compiler and Run Java program via Terminal:          $ javac name.java  $ java name                            static type for all variables and expressions                  Variables must be declared before it is used, and must have a specific type and the type can never change.                          Let the programmer know exactly what sort of objekt is working with              No type erros                                        int x = 0;        string x = &quot;test&quot;;  // error                            System.out.print will not print a newline (return), System.out.println will print a newline.                    @param name a varialbe        /*** @param variable name * @param expected Expected double* * or** @param(&quot;name&quot;) String variable*/                            static final to declare any constans, e.g. the gravitational constant G        private static final double G = 6.67e-11;                            for-each loop: to iterate through elements of arrays and collections        /* for (type var : array) { }; */int[] numArray = { 1, 2, 3, 4, 5, 6 };        for (int i : numArray) {        System.out.print(i);    }    // -&amp;gt; 123456     /* is equivalent to: */int[] numArray = { 1, 2, 3, 4, 5, 6 };       for (int i = 0; i &amp;lt; numArray.length; i++) {        int j = numArray[i];	// j is i in first case     System.out.println(j);    }                          Functions:          Functions must be declared as part of a class. A function that is part of a class is method, so all functions are methods.                  To define a function use public static (e.g. Python def).          All parameters of a functions must be declared.                        public class LargerDemo {      /** Returns the larger of x and y. */      public static int larger(int x, int y) {          if (x &amp;gt; y) {              return x;          }          return y;      }          public static void main(String[] args) {          System.out.println(larger(8, 10));      }  }            Class                  Examle:        /* Dog.java */public class Dog {		// non-static    public int weightInPounds;		// instance variable             /* One integer constructor for dogs */    public Dog(int w) {		// e.g. python def __init__        weightInPounds = w;    }            public void makeNoise() {		// non-static method         if (weightInPounds &amp;lt; 10) {            System.out.println(&quot;yip!&quot;);        } else if (weightInPounds &amp;lt; 30) {            System.out.println(&quot;bark&quot;);        } else {            System.out.println(&quot;wooof!&quot;);        }    }}    /* DogLauncher.java */public class DogLauncher {		  // client of Dog class    public static void main(String[] args) {        Dog d = new Dog();			// Declaration a new variable of type Dog        d.weightInPounds = 51;	// Instantiation        d.makeNoise();				 // Invocation    }}    &amp;gt; javac Dog.java&amp;gt; javac DogLauncher.java&amp;gt; java DogLauncherwooof!                          A class that uses another class is sometimes called a “client” of that class, i.e. DogLauncher is a client of Dog.          Instance variables or non-static variables must be declared inside the class.          The makeNoise() is a non-static / instance method, and do not have the static keyword. If the method is going to be invoked by an instance of the class, then it should be non-static. It means, if one method needs to use the instance variable, the method must be non-static.                          To call the makeNoise method should using the new keyword to instantiate a Dog, then call d.makeNoise().                                The constructor with signature public Dog(int w) will be invoked anytime that we try to create a Dog using the new keyword and a single integer parameter. Similar to Python __init__ method.                            Non-static Methods are actions that can be taken only by a specific instance of a class.        Math m = new Math();x = m.sqrt(100);                            Static methods are actions that are taken by the class itself.        x = Math.sqrt(100);                            Non-static:        public Dog maxDog(Dog d2) {	 // non-static method    if (this.weightInPounds &amp;gt; d2.weightInPounds) {        return this;	// use the keyword this to refer to the current object    }    return d2;}    /* invoke */Dog d = new Dog(15);	Dog d2 = new Dog(100);d.maxDog(d2);                            Static:        public class Dog {    public int weightInPounds;    public static String binomen = &quot;Canis familiaris&quot;;	// static variable    ...}    /* invoke */Dog.binomen                          Arrays of objects          use new keyword to create the array      use new again for each object that needs to put in the array        /* example 1 */Dog[] dogs = new Dog[2];		// Creates an array of Dogs of size 2dogs[0] = new Dog(8);			  // dog 1 has value of 8 dogs[1] = new Dog(20);dogs[0].makeNoise();			  // dog 1 invoke the method   /* example 2 */int[] name = new int[5];name[0] = 1;name[1] = 2;   /* example 3*/int[] myList = {1, 2, 3};      2. Lists2.1 SLList (Singly Linked List)public class IntNode {    public int item;    public IntNode next;    public IntNode(int i, IntNode n) {        item = i;        next = n;    }}public class SLList {    public IntNode first;        public SLList(int x) {        first = new IntNode(x, null);    }        /** Adds x to the front of the list. */    public void addFirst(int x) {        first = new IntNode(x, first);    }      /** Returns the first item in the list. */    public int getFirst() {        return first.item;    }        public static void main(String[] args) {        /* Creates a list of one integer, namely 10 */      	SLList L = new SLList(10);        L.addFirst(10);        int x = L.getFirst();	// outputs 10    }}      Public vs. Private    /* change public to private */private IntNode first;              Private variables and methods can only be accessed by code inside the same .java file, e.g. in this case SLList.java. Other class can not invoke first. But can through public methods like public void addFirst to invoke or edit first.            Nested Class          Put a class inside of another class. Do not need two java files.      If the nested class has no need to use any of the instance methods or variables of enclosing class, then can declare with static. Which means that methods inside of static class can not access any of the members of the enclosing class.      e.g. IntNode class is depends on SLList class, so can put in inside of SLList        public class SLList {     private class IntNode {        public int item;        public Node next;          public IntNode(int i, IntNode n) {            item = i;            next = n;        }    }        public IntNode first;    public SLList(int x) {        first = new IntNode(x, null);    }          /** Adds an item to the front of the list */    public void addFirst(int x) {        first = new IntNode(x, first);    }          public int getFirst() {        return first.item;    }          public static void main(String[] args) {        SLList L = new SLList(15);        L.addFirst(10);        int x = L.getFirst();    }}                      addLast and size        /** Adds an itemto the end of the list. */public void addLast(int x){  IntNote p = first;        /* Move p until it reaches the end of the list. */  while (p.next != null){    p = p.next;  }        p.next = new IntNote(x, null);}    /** helper function 	* Returns the size of the list that starts at IntNode p. */private static int size(IntNode p) {    if (p.next == null) {        return 1;    }    return 1 + size(p.next);}    public int size() {    return size(first);}                          use private static for helper function, to define this function can not invoked by outside.          addLast() is slow. Because we have to start at the front, and loop all the way to the back of our list before adding our element.                            Sentinel Nodes:        /** Creates an empty SLList */public SLList(){  sentinel = new IntNode(100, null);  size = 0;}    public SLList(int x){  sentinel = new IntNode(100, null);  sentinel.next = new IntNode(x, null);  size = 1;}     public void addFirst(int x){  sentinel.next = new IntNode(x, sentinel.next);  size += 1;}    public int getFirst(){  return sentinel.next.item;}    public void addLast(int x) {    size += 1;    IntNode p = sentinel;          while (p.next != null) {        p = p.next;    }        p.next = new IntNode(x, null);}                          It’s the first node and it’s a dummy node, and not contains in the list.          It can be any number, because it will not be used. Its for addLast.          A SLList with a sentinel node has at least the following invariants:                          The sentinel reference always points to a sentinel node.              The front item (if it exists), is always at sentinel.next.item.              The size variable is always the total number of items that have been added.              Inserting at the back of an SLList is much slower than the front.                                          2.2  DLList (Doubly Linked List)      A node has a pointer to the next and the previous node. There’s two way to implement it:                  Double Sentinel: There’s a Sentinel Node at front and the end. SentFront.next is points to the first real Node, prev points to null. And SentBack.next points to null, prev points to the last real Node.                            Circular Sentinel: Only need one Sentinel Node, and this Sentinel Node next points to the first real Node, prev points to the last real Node. If there’s no node, next and prev point to itself.                          Generic List: &amp;lt;PLACEHOLDER&amp;gt; after the class name. This allows the list to work not only for int, but also for i.e., string too.    /** Make a placeholder for this class, so you can declare the type later */public class DLList&amp;lt;HERE&amp;gt; {    private IntNode sentinel;    private int size;      public class IntNode {        public IntNode prev;        public HERE item;        public IntNode next;        ...    }    ...}  /** HERE is now Integer, so d1 is a int */DLList&amp;lt;Integer&amp;gt; d1 = new DLList&amp;lt;&amp;gt;(5);d1.insertFront(10);  /** HERE is now String, so d2 is a String */DLList&amp;lt;String&amp;gt; d2 = new DLList&amp;lt;&amp;gt;(&quot;hello&quot;);d2.addLast(&quot;world&quot;);              int: Integer      double: Double      char: Character      boolean: Boolean      long: Long      2.3  AList (Array List)  There are three valid notations for array creation          y = new int[3];      x = new int[]{1, 2, 3, 4, 5};      int[] w = {9, 10, 11, 12, 13};            2D Array    int[][] pascalsTriangle;					// declarationpasacalsTriangle = new int[4][];	// a 2D array contains four 1D array  pascalsTriangle[0] = new int[]{1};// give a value at position 0  int[][] matrix;matrix = new int[4][4];					 // four 2D array contain 5 int 1D array   /** all togher */int[][] pascalAgain = new int[][]{ {1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}};            Alist:    public class AList&amp;lt;T&amp;gt; {    private T[] items;    private int size;          /** Creates an empty list */    public AList() {      	/* Casts, if we want to use &amp;lt;T&amp;gt;: must new a Objetc            then transfer the arrys type */        items = (T[]) new Object[100];        size = 0;    }        	/** Resizes the underlying array to the target capacity */    public void resize(int capacity) {        T[] a = (T[]) new Object[capacity];        System.arraycopy(items, 0, a, 0, size);        items = a;    }          /** Inserts X into the back of the list */    public void addLast(T x) {        /* Resize items since its full */        if (size == items.length) {          /* faster */           resize(size * 2);         }        items[size] = x;        size = size + 1;    }          /** Returns the item from the back of the list */    public T getLast() {        return items[size - 1];    }         	/** Deletes item from back of the list and returns deleted item */	    public int removeLast() {        int last = getLast();      	/* not necessary */        items[size-1] = null;	        size = size - 1;        return last;    }}      2.4 Deque (Double ended queue)  Specifically, any deque implementation must have exactly the following operations:          public void addFirst(T item): Adds an item of type T to the front of the deque.      public void addLast(T item): Adds an item of type T to the back of the deque.      public boolean isEmpty(): Returns true if deque is empty, false otherwise.      public int size(): Returns the number of items in the deque.      public void printDeque(): Prints the items in the deque from first to last, separated by a space.      public T removeFirst(): Removes and returns the item at the front of the deque. If no such item exists, returns null.      public T removeLast(): Removes and returns the item at the back of the deque. If no such item exists, returns null.      public T get(int index): Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth. If no such item exists, returns null. Must not alter the deque!            Linked List Deque:    /* Empty Linked List -&amp;gt; sentinel is a node with value null. */public LinkedListDeque() {    sentinel = new Node&amp;lt;T&amp;gt;();    sentinel.next = sentinel;    sentinel.prev = sentinel;    size = 0;}  /* Adds an item to the front / back of the deque. */public void addFirst(T item) {  Node&amp;lt;T&amp;gt; firstNode = new Node&amp;lt;T&amp;gt;(item);  /* save the next node of sentinel in `next`, which should be pos 1. */  Node&amp;lt;T&amp;gt; next = sentinel.next;  /* copy `next`. */  firstNode.next = next;  /* points firstNode is the prev node of `next` */  next.prev = firstNode;  /* relocated the sentinel node */  sentinel.next = firstNode;  firstNode.prev = sentinel;    size += 1;}  public void addLast(T item) {    Node&amp;lt;T&amp;gt; lastNode = new Node&amp;lt;T&amp;gt;(item);    /* the prev node of the sentinel node points to the last node. */    Node&amp;lt;T&amp;gt; prev = sentinel.prev;      lastNode.prev = prev;    prev.next = lastNode;    sentinel.prev = lastNode;    lastNode.next = sentinel;      size += 1;}  /* Prints the items in the deque from first to last. */public void printDeque() {    for (Node&amp;lt;T&amp;gt; ptr = sentinel.next; ptr != sentinel; ptr = ptr.next) {        System.out.print(ptr.item + &quot; &quot;);    }}  /* Removes and returns the item at the fonrt / back of the deque. */public T removeFirst() {    return remove(sentinel.next);}  public T removeLast() {    return remove(sentinel.prev);}  /* The helper function, see the grafic above */private T remove(Node&amp;lt;T&amp;gt; node) {    if (size == 0) {        return null;    }      Node&amp;lt;T&amp;gt; tempNext = node.next;    Node&amp;lt;T&amp;gt; tempPrev = node.prev;      tempPrev.next = tempNext;    tempNext.prev = tempPrev;    size--;      return node.item;}                      Array Deque:                              uses a circular array with two pointers head and tail. They both start at the same position, then the head pointer starts from back to front and the tail pointer from front to the end. If they meet again (head equals tail) it means the array is full.                                Null is not allowed to add into the ArrayDeque.                                addFirst():            public void addFirst(T item) {  if (item == null) {      throw new NullPointerException();  }        head = (head - 1 + elements.length) % elements.length;  elements[head] = item;  size++;        if (head == tail) {      calculateSize(size * GROWTH_FACTOR);  }}                                      Two pointer should move like circle. The different is that the head pointer moves backward (from index 0 to the end n then n-1, n-2 and so on), e.g. if element.length = 4 and head = 0 then 3 % 4 = 3, so item adds on index 3.              If the array is full, it should double its size.                                                        addLast():            public void addLast(T item) {  if (item == null) {      throw new NullPointerException();  }        elements[tail] = item;  tail = (tail + 1) % elements.length;  size++;        if (head == tail) {      calculateSize(size * GROWTH_FACTOR);  }}                                      The tail pointer moves forward (from 0 to 1 to 2 and so on).                                            removeFirst():            public T removeFirst() {    if (isEmpty()) {        return null;    }          T item = elements[head];          elements[head] = null;          head = (head + 1) % elements.length;    size--;          if (size &amp;gt; INITIAL_LENGTH &amp;amp;&amp;amp; size &amp;lt; elements.length / 				 DOWN_USAGE_FACTOR) {        calculateSize(elements.length / GROWTH_FACTOR);    }    return item;}                                      First set the head pointer’s value as null then head should move circular forward (because the addFirst was backward).              If after remove the value the array size is too big ((the number of elements / the array’s length) &amp;lt; usage Factor), the array should reduce to save the memory.                                                        removeLast():            public T removeLast() {    if (isEmpty()) {        return null;    }          tail = ((tail - 1) + elements.length) % elements.length;          T item = elements[tail];          elements[tail] = null;    size--;          if (size &amp;gt; INITIAL_LENGTH &amp;amp;&amp;amp; size &amp;lt; elements.length / DOWN_USAGE_FACTOR) {        calculateSize(elements.length / GROWTH_FACTOR);    }    return item;}                                      First move the tail pointer backward (the addLast was forward), because the value of last item stored at the previous index of the tail pointer. Then set the value as null.                                            calculateSize():            private void calculateSize(int newSize) {    T[] resized = (T[]) new Object[newSize];    /* V1 */    for (int i = 0; i &amp;lt; size; i++) {        int src = (head + i) % elements.length;        int dest = i;        resized[dest] = elements[src];    }          /* V2 */    if (size + head &amp;lt; elements.length) {        System.arraycopy(elements, head, resized, 0, size);    } else {        /* Copy left side items of the head pointer. */        System.arraycopy(elements, head, resized, 0, elements.length - head);        /* Copy right side items of the head pointer. */        System.arraycopy(elements, 0, resized, elements.length - head, head);    }          elements = resized;    head = 0;    tail = size;}                                                  If the array is full, it should double its size. If the usage factor is too low, it should reduce its size. There’s two way to implementate this.                                      Uses for loop to copy the array into the new array with new size. It can avoid to adds nulls. Similar to the get(), simply copy all items after head.              Uses System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length). There’s two situations:                                  if size + head &amp;lt; elements.length: the number of items plus the index of the head is still less than the length of the array, it means there’s nulls on the left side of the head. In this case it should only copy the right side of the head.                  Otherwise, just copy the items on the left and right sides of the head pointer separately.                                                                          get():            public T get(int index) {    if (isEmpty() || index &amp;gt; size) {        return null;    }          int theIndex = (head + index) % elements.length;    return elements[theIndex];}                                      The input index is not the “real” index, because the head pointer is where the array starts, so the head is our index 0. It means the real index is after the head which is (head+inde).                                          2.5 Built-in List      Lists:    import java.util.List;import java.util.ArrayList;  public class Example {    public static void main(String[] args) {        List&amp;lt;Integer&amp;gt; L = new ArrayList&amp;lt;&amp;gt;();        L.add(5);        L.add(10);        System.out.println(L);    }}            Sets:    import java.util.Set;import java.util.HashSet;  Set&amp;lt;String&amp;gt; s = new HashSet&amp;lt;&amp;gt;();s.add(&quot;Tokyo&quot;);s.add(&quot;Lagos&quot;);System.out.println(S.contains(&quot;Tokyo&quot;)); // true      3. Testing  Ad Hoc Testing/** Tests the Sort class. */public class TestSort {    /** Tests the sort method of the Sort class. */    public static void testSort() {        String[] input = {&quot;i&quot;, &quot;have&quot;, &quot;an&quot;, &quot;egg&quot;};        String[] expected = {&quot;an&quot;, &quot;egg&quot;, &quot;have&quot;, &quot;i&quot;};              Sort.sort(input);              for (int i = 0; i &amp;lt; input.length; i += 1) {            if (!input[i].equals(expected[i])) {                System.out.println(&quot;Mismatch in position &quot; + i + &quot;,                                    expected: &quot; + expected + &quot;, but got: &quot; +                                   input[i] + &quot;.&quot;);                break;            }        }    }    public static void main(String[] args) {        testSort();    }}      JUnit Testing          Precede each method with @org.junit.Test (no semi-colon).      Change each test method to be non-static.      Remove our main method from the TestSort class.      Run the Code: Run -&amp;gt; Run…      import org.junit.Test; -&amp;gt; simply use @Test      import static org.junit.Assert.*; -&amp;gt; assertEquals(&amp;lt;expected&amp;gt;, &amp;lt;actual&amp;gt;)      default renderer: red/green arrows        jh61b renderer: white/blue boxes          See “Selection Sort”        public static void testSort() {    String[] input = {&quot;i&quot;, &quot;have&quot;, &quot;an&quot;, &quot;egg&quot;};    String[] expected = {&quot;an&quot;, &quot;egg&quot;, &quot;have&quot;, &quot;i&quot;};    Sort.sort(input);  	/* Use `org.junit` library */    org.junit.Assert.assertArrayEquals(expected, input);}            Selection Sort          Find the smallest item.      Move it to the front.      Selection sort the remaining N-1 items (without touching the front item).        /* Sort Class */public class Sort {    /** Sorts strings destructively. */    public static void sort(String[] x) {        /* selection sort the rest (using recursion by helper methods) */			sort(x, 0);    }      	/** Sorts strings destructively starting from item start. */    private static void sort(String[] x, int start) {        if (start == x.length) {           return;       }       /* find the smallest item */   		int smallestIndex = findSmallest(x, start);       /* move it to the front */       swap(x, start, smallestIndex);       sort(x, start + 1);    }    	/** Swap item a with b */  	public static void swap(String[] x, int a, int b) {        String temp = x[a];        x[a] = x[b];        x[b] = temp;		}        /** Returns the smallest string in x. */    public static int findSmallest(String[] x, int start) {        int smallestIndex = start;        for (int i = start; i &amp;lt; x.length; i += 1) {            int cmp = x[i].compareTo(x[smallestIndex]);            if (cmp &amp;lt; 0) {                smallestIndex = i;            }        }        return smallestIndex;    }}        import org.junit.Test;import static org.junit.Assert.*;  /* TestSort Class */public class TestSort {    ...    /** Test the Sort.findSmallest method. */    @Test    public void testFindSmallest() {        String[] input = {&quot;i&quot;, &quot;have&quot;, &quot;an&quot;, &quot;egg&quot;};        int expected = 2;          int actual = Sort.findSmallest(input, 0);        /* org.junit.Assert.assertEquals(expected, actual); */        	assertEquals(expected, actual);           String[] input2 = {&quot;there&quot;, &quot;are&quot;, &quot;many&quot;, &quot;pigs&quot;};        int expected2 = 2;          int actual2 = Sort.findSmallest(input2, 2);        /* org.junit.Assert.assertEquals(expected2, actual2); */      	assertEquals(expected2, actual2);    }        /** Test the Sort.swap method. */  	@Test    public void testSwap() {        String[] input = {&quot;i&quot;, &quot;have&quot;, &quot;an&quot;, &quot;egg&quot;};        int a = 0;        int b = 2;        String[] expected = {&quot;an&quot;, &quot;have&quot;, &quot;i&quot;, &quot;egg&quot;};          Sort.swap(input, a, b);        /* org.junit.Assert.assertArrayEquals(expected, input); */      	assertArrayEquals(expected, input);    }}            of method: for example, to create an IntList containing the numbers 0, 1, 2, and 3, we could use the method as follows:    IntList myList = IntList.of(0, 1, 2, 3);// Creates the IntList 0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; null              myList.first returns 0      myList.rest returns 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; null      myList.rest.rest.rest returns 3 -&amp;gt; null      myList.rest.rest.rest.rest returns null        Style Checker: right Klic at the .java in IDEA - Checking Style4. Inheritance4.1 Intro and Interfaces      Method Overloading: Java allows multiple methods with same name, but different parameters.    public static String longest(SLList&amp;lt;String&amp;gt; list)public static String longest(AList&amp;lt;String&amp;gt; list)              When you call WordUtils.longest, Java knows which one to run according to what kind of parameter you supply it. If you supply it with an AList, it will call the AList method. Same with an SLList.            Interface Inheritance: is a specification of what a List is able to do (methods and parameters), not how to do. The subclass must have all methods of the interface. Use the keyword interface.          Step 1:        public interface List61B&amp;lt;T&amp;gt; {    public voif addLast(T x);    public T getLast();    public T get(int i);    public int size();    public T removeLast();    public void insert(T x, int position);    public void addFirst(T x);    public T getFirst();}              Step 2: use the keyword implements        public class AList&amp;lt;T&amp;gt; implements List61B&amp;lt;T&amp;gt; {    ...    public void addLast(T x) {        ...    }}              The qualities of interfaces:                  All methods must be public.          All variables must be public static final.          Cannot be instantiated          All methods are by default abstract unless specified to be default          Can implement more than one interface per class                          Overriding and Overloading:                  Override: a subclass has a method with the exact same signature as in the superclass        public interface Animal {	public void makeNoise();}    /** Pig overrides makeNoise() */public class Pig implements Animal {	public void makeNoise() {		System.out.print(&quot;oink&quot;);	}}                            Overload: a subclass has a method with the same name but different signatures as in the superclass        /** makeNoise is overloaded */public class Dog implements Animal {	public void makeNoise(Dog x) {		...	}}    /** absis overloaded */public class Math {  public int abs(int a)  public double abs(double a)}                            use @Override tag at the top for all methods that been overrided.                  Implementation Inheritance: tells the subclasses how they should behave. Subclasses can inherit signatures and implementation. You must include the default keyword in the method signature.    public interface List61B&amp;lt;T&amp;gt; {    ...    default public void print() {        for (int i = 0; i &amp;lt; size(); i += 1) {            System.out.print(get(i) + &quot; &quot;);        }        System.out.println();    }}        For an SLList, the get method needs to jump through the entirety of the list. during each call. It’s much better to just override the print method.    @Overridepublic void print() {    for (Node p = sentinel.next; p != null; p = p.next) {        System.out.print(p.item + &quot; &quot;);    }}            Extends: uses the extends keyword to inherit a class not interface, this defines “is-a” relationship. Subclasses inherit all members of the parent class. “Members” includes: all instance and static variables, all methods and all nested classes.                  Note that constructors are not inherited, and private members cannot be directly accessed by subclasses.        public class RotatingSLList&amp;lt;Item&amp;gt; extends SLList&amp;lt;Item&amp;gt; {  /** Rotates list to the right. */  public void rotateRight() {    Item x = removeLast();    addFirst(x);	}}                            If we want to override a method and call this method defined in the parent class, using the super keyword. e.g. removeLast        public class VengefulSLList&amp;lt;Item&amp;gt; extends SLList&amp;lt;Item&amp;gt; {    SLList&amp;lt;Item&amp;gt; deletedItems;        public VengefulSLList() {        deletedItems = new SLList&amp;lt;Item&amp;gt;();    }        @Override    public Item removeLast() {        Item x = super.removeLast();	// Using super keyword        deletedItems.addLast(x);        return x;    }        /** Prints deleted items. */    public void printLostItems() {        deletedItems.print();    }}                            Constructors Are Not Inherited: Uses the super keyword to call parent’s constructor.        public VengefulSLList() {    super();    deletedItems = new SLList&amp;lt;Item&amp;gt;();}                          Adding super() has no difference from the constructor before (Line 4 to 6). And super() will implicit call to the default constructor, so it must call the constructor explict e.g. super(x).                          Higher Order Functions:          In old school Java (Java 7 and earlier), memory boxes (variables) could not contain pointers to functions. To get around this we can take advantage of interface inheritance.        /** Reprensent a function that takes in an integer and returns an integer */public interface IntUnaryFunction {    int apply(int x);}        public class TenX implements IntUnaryFunction {    public int apply(int x) {        return 10 * x;    }}        /** Demonstrates higher order functions in java */public class HofDemo {    public static int do_twice(IntUnaryFunction f, int x) {        return f.apply(f.apply(x));    }          public static void main(String[] args) {        IntUnaryFunction tenX = new TenX();        System.out.println(do_twice(tenX, 2))    }}      4.2 Polymorphism  Polymorphism refers to how objects can have many forms or types. In object-oriented programming, polymorphism relates to how an object can be regarded as an instance of its own class, an instance of its superclass, an instance of its superclass’s superclass, and so on.      We can create an interface that guarantees that any implementing class, like Dog, contains a comparison method, which we’ll call compareTo.    public static OurComparable max(OurComparable[] items) {    int maxDex = 0;    for (int i = 0; i &amp;lt; items.length; i += 1) {        int cmp = items[i].compareTo(items[maxDex]);        if (cmp &amp;gt; 0) {            maxDex = i;        }    }    return items[maxDex];}        public interface OurComparable {        /**     	* Return negative number if this &amp;lt; o      * Return 0 if this equals o   	  * Return positive number if this &amp;gt; o   	  */    public int compareTo(Object o);}        public class Dog implements OurComparable {    private String name;    private int size;          public Dog(String n, int s) {        name = n;        size = s;    }          public void bark() {        System.out.println(name + &quot; says: bark&quot;);    }          /** the interface */     public int compareTo(Object o) {        Dog uddaDog = (Dog) o;        return this.size - uddaDog.size;        }    }}                      By declaring that it implements OurComparable, the Dog class makes a claim that it “is-an” OurComparable. As a result, the compiler checks that this claim is actually true, but sees that Dog doesn’t implement compareTo. The solution is to use the built-in interface Comparable&amp;lt;T&amp;gt;.        public interface Comparable&amp;lt;T&amp;gt; {    public int compareTo(T obj);  }                public class Dog implements Comparable&amp;lt;Dog&amp;gt; {    /** Avoid cast an object */    public int compareTo(Dog uddaDog) {        return this.size - uddaDog.size;    }}                          Comparator: use java.util.Comparator to define how two objects compare, e.g. by their name.    public interface Comparator&amp;lt;T&amp;gt; {    int compare(T o1, T o2);}      4.3 Abstract Class      The three most important Abstract data type (ADTs) come in the java.util library:                  List: an ordered collection of items, e.g. Linked List, ArrayList                    Set: an unordered collection of strictly unique items (no repeats), e.g. HashSet, TreeSet                    Map: a collection of key/value pairs like dictionary in python. You access the value via the key, e.g. HashMap, TreeMap                  Abstract Classes:          Use the keyword abstract.      Subclass use the keyword extends and can only extend one abstract class.      Can do anything an interface can do and more.      Methods can be public or private      Can have any types of variables      Cannot be instantiated      Methods are by default concrete unless specified to be abstract      Can only implement one per class        public abstract class GraphicObject {      public int x, y;      public void moveTo(int newX, int newY) {...}      public abstract void draw(); }       4.4 Pakagespackage_name.classname.subclassname a = new package_name.classname.subclassname();import package_name.classname.subclassname;5. Java Syntax5.1 Autoboxing &amp;amp; Auto-unboxing      Autoboxing is the Java’s automatic conversion of between wrappers (Integer) to primitives (int).        Automatic Conversions:    public class BasicArrayList {    public static void main(String[] args) {        ArrayList&amp;lt;Integer&amp;gt; L = new ArrayList&amp;lt;Integer&amp;gt;();        L.add(5);   					// normally should be: L.add(new Integer(5))        int first = L.get(0);  // normally should be: L.get(0).valueOf();    }}                      If Java code expects a wrapper type (e.g. Integer) and gets a primitive, it is auto boxed.        public static void blah(Integer x) {  System.out.println(x);}    int x = 20;blah(x);                            Likewise, if the code expects a primitive (e.g. int) and gets a wrapper, it is unboxed.        public static void blahPrimitive(int x) {  System.out.println(x);}    Integer x = new Integer(20);blahPrimitive(x);                          There are a few things to keep in mind when it comes to autoboxing and unboxing:          Arrays are never autoboxes or auto-unboxed, e.g. if you have an array of integers int[] x, and try to put its address into a variable of type Integer[], the compiler will not allow your program to compile.      Autoboxing and unboxing also has a measurable performance impact. That is, code that relies on autoboxing and unboxing will be slower than code that eschews such automatic conversions.      Additionally, wrapper types use much more memory than primitive types. On most modern comptuers, not only must your code hold a 64 bit reference to the object, but every object also requires 64 bits of overhead used to store things like the dynamic type of the object.      5.2 Immutability      An immutable data type is a data type whose instances cannot change in any observable way after instantiation. The final keyword will help the compiler ensure immutability.        Declaring a reference as final does not make the object that reference is pointing to immutable! For example, consider the following code snippet:    public final ArrayDeque&amp;lt;String&amp;gt;() deque = new ArrayDeque&amp;lt;String&amp;gt;();              The deque variable is final and can never be reassigned, but the array deque object its pointing to can change! ArrayDeques are always mutable!      5.3 Exception      e.g. If the value at items[i] is null, then we are calling null.equals(x) -&amp;gt; NullPointerException. In Java, Exceptions are objects and we throw exceptions explicit using the following format:    throw new ExceptionObject(parameter1, ...);      // e.g.  throw new IllegalArgumentException(&quot;...&quot;);      5.4 Iteration      Enhanced For Loop, its like for … in from Python.    Set&amp;lt;String&amp;gt; s = new HashSet&amp;lt;&amp;gt;();s.add(&quot;Tokyo&quot;);s.add(&quot;Lagos&quot;);for (String city : s) {    System.out.println(city);}            Iterator: to run the code below, be sure that          the List interface has an iterator() method, since friends is a List, on which iterator() is called.      And the Iterator interface has next/hasNext() methods, since seer is an Iterator, on which hasNext() and next() are called.        List&amp;lt;Integer&amp;gt; friends = new ArrayList&amp;lt;Integer&amp;gt;();Iterator&amp;lt;Integer&amp;gt; seer = friends.iterator();  while (seer.hasNext()) {    System.out.println(seer.next());}                      To implement these requirements, the List&amp;lt;T&amp;gt; interface extends the Iterable interface, inheriting the abstract iterator() method. Then check that Iterators have hasNext() and next().        // 1.public interface Iterable&amp;lt;T&amp;gt; {    Iterator&amp;lt;T&amp;gt; iterator();}    public interface List&amp;lt;T&amp;gt; extends Iterable&amp;lt;T&amp;gt;{    ...}    // 2.public interface Iterator&amp;lt;T&amp;gt; {    boolean hasNext();    T next();}                    "
  },
  
  {
    "title": "LeetCode Python",
    "url": "/posts/LeetCode-Python/",
    "categories": "Note, CS",
    "tags": "leetcode, python",
    "date": "2022-06-15 10:11:11 +0000",
    





    "snippet": "HashTable (Algo catalog by use ##2)Simple / Medium / Hard Catalog1. Two Sum (name of the questions)InhaltIdea for the solution, explanationCodeusing ** ** without  space to create a line betwenn two questions"
  },
  
  {
    "title": "Python Note",
    "url": "/posts/Python-Note/",
    "categories": "Note, CS",
    "tags": "note, python",
    "date": "2022-06-01 10:11:11 +0000",
    





    "snippet": "1 Introduction  install pip:  $ curl https://bootstrap.pypa.io/pip/get-pip.py -o get-pip.py  $ sudo python3 get-pip.py  Some Commands:          control + d: exit()      control + l: clear      python3 -i name.py      handle = open(filename, mode)      quit(): break      dict_name.get(xxx, 0) + 1: if in dict() has xxx then xxx+1 otherwise 0+1      range(start, stop, step)      for j in range(i+1, xxx): the step is i+1        Position of numbers without []:&amp;gt;&amp;gt;&amp;gt; n = 18117&amp;gt;&amp;gt;&amp;gt; all_but_last, last = n // 10, n % 10all_but_last = 1811   # via //last = 7              # via %  Placeholder:          %d: decimal      %f: float      %%: percent      e.g.: print(&#39;%d + %d = %d&#39; % (a, b, a + b))       2 Coursera: PY4E2.1 Fundations  Regular Expressions and Extracting Data:          import re      re.search()      re.findall()      see e9.py                  Symbol      Explanation                  ^      Matches the beginning of a line              $      Matches the end of the line              .      Matches any character              \\s      Matches whitespace              \\S      Matches any non-whitespace character              *****      Repeats a character zero or more times              *?      Repeats a character zero or more times (non-greedy)              +      Repeats a character one or more times              +?      Repeats a character one or more times (non-greedy)              [aeiou]      Matches a single character in the listed set              [^XYZ]      Matches a single character not in the listed set              [a-z0-9]      The set of characters can include a range              ( )      Only show date inside of ()        Socket          import socket      Port 80: Web Server, HTTP(80)      decode()        Retrieving Web Pages          use Chrome to view the page source      import urllib.request, urllib.parse, urllib.error      fhand = urllib.request.urlopen(&#39;http://xxxxx&#39;)for line in fhand:	print(line.decode().strip())      Beautifulsoup4: e11.py          from bs4 import BeautifulSoup      Example to get img: https://divertingpan.github.io/post/python_tieba/        1) download BeautifulSoup4    2) unzip and Terminal geht to the folder    3) sudo python3 ./setup.py i nstall    4) pip install soupsieve    eXtensible Markup Language (XML)          share structured data      import xml.etree.ElementTree as ET      xxx.findall(‘a/b’): find all tags b from a        JavaScript Object Notation (JSON)          import json      &#39;&#39;&#39;[ xxx ]&#39;&#39;&#39;      info = json.loads(xxx)        Service Oriented Approach          Application Programming Interfaces (API)      import twurl      twurl.augment(url, {‘xx’})      GeoJason API: http://maps.googleapis.com/maps/api/geocode/json?        assert expression:          test if expression is False: assert 1 == 0, &#39;xxx&#39;. This is False, so show &#39;xxx&#39;      assert 1 == 1, ‘xxx’. This is True, show nothing.      2.2 Examples  Example e1:          if error, still accept, then run yyy and continue.      try: 	xxx      except ValueError: 	yyy 	continue  Example e2:          find position, print out xxx between position 1 and 2.      text = abcdef n1 = text.find(&#39;c&#39;)n2 = text.find(&#39;f&#39;)n3 = text[n1:n2+1]print(n3)  Example e3:          use os function to use os.getcwd() to now the path and use os.chdir() to change the path      rstrip(): move the blank line      import osprint(os.getcwd())os.chdir(&#39;/Users/Terry/Desktop&#39;)# Use words.txt as the file namefname = input(&quot;Enter file name: &quot;)fh = open(fname)for line in fh:    line = line.rstrip()    line = line.upper()    print(line)  Example e5:          lst.split() error, so should use lst[0].split() to remove blank.      list(set(xx)) to remove repeated elements      fname = input(&quot;Enter file name: &quot;)fh = open(fname)lst = list()new = list()count = 0 for line in fh:    line = line.rstrip()    lst.append(line)    new = new + lst[count].split()     count = count + 1 new = list(set(new))new.sort()print(new)  Example e14:# compute the sum of the numbers in the file and enter the sum# the numbers are inside tag &#39;count&#39;address = input(&#39;Enter location: &#39;)url = address print(&#39;Retrieving&#39;, url)uh = urllib.request.urlopen(url, context=ctx)data = uh.read()print(&#39;Retrieved&#39;, len(data), &#39;characters&#39;)tree = ET.fromstring(data)sum = 0# locatate &#39;count&#39; and find them allcounts = tree.findall(&#39;.//count&#39;)print(&#39;Count:&#39;, len(counts))for count in counts:    # the numbers are &#39;text&#39; from count    sum += int(count.text)print(sum)  Databases: e17.py and e18.py          SQLite Browser      import sqlite3      Reconstructing Data with JOIN: select … from … join … on …      inside python code, should use SQL code:      xyz.execute(&#39;UPDATE xxx SET yyy=xxx WHERE xxxx&#39;)xxx = sqlite.connect(&#39;xxx.sqlite&#39;)yyy = xxx.cursor()yyy.execute(&#39;SQL code&#39;)3 CS61A Fall 2020See here for this course.3.1 Introduction  *args and **kwargs:          *args: unknown functions/parameters      **kwargs: same but list      def printed(f):     	def print_and_return(*args):         	result = f(*args)         	print(&#39;Result:&#39;, result)         	return result     	return print_and_return&amp;gt;&amp;gt;&amp;gt; printed_pow = printed(pow)&amp;gt;&amp;gt;&amp;gt; printed_pow(2, 8)Result: 256256&amp;gt;&amp;gt;&amp;gt; printed_abs = printed(abs)&amp;gt;&amp;gt;&amp;gt; printed_abs(-10)Result: 1010  Higher-Order Functions:          use function inside of function      def apply_twice(f, x):    return f(f(x))  	# here call the f function with x, f can be i.e. square def square(x):    return x * x&amp;gt;&amp;gt;&amp;gt; apply_twice(square, 2)      # f is now the function square(x) with x = 216  Lambda Expressions:          lambda &amp;lt;parameters&amp;gt;: &amp;lt;return expression&amp;gt;      (lambda &amp;lt;parameters A&amp;gt;: &amp;lt;return function&amp;gt;)(lambda &amp;lt;parameters A&amp;gt;: lambda &amp;lt;parameters B&amp;gt;:  &amp;lt;return expression&amp;gt;)      lambda is a function with formal parameter x=10 that returns the value of x*x, it’s like def      x = 10square = x * xsquare = lambda x: x * x	print(square(4))      List                  Time increases with more elements                    Memory small                    append() to add an element in list                    insert() to add an element in a position of list, e.g.:        ​		&amp;gt;&amp;gt;&amp;gt; lst = [1, 2, 3]        ​		&amp;gt;&amp;gt;&amp;gt; lst.insert(1,5)        ​		[1,5,2,3] in position [1] add 5            extend([&#39;a&#39;, &#39;b&#39;]) to add elements in list      pop() to remove the final element or pop(x) to remove element at index x      remove(&#39;xx&#39;) remove the first element named xx      sort() to sort elements in list      split() to remove element (here (none)) from the list      lst[::-1] creates a reversed list      &amp;gt;&amp;gt;&amp;gt; directors = [&#39;jenkins&#39;, &#39;spielberg&#39;, &#39;bigelow&#39;, &#39;kubrick&#39;]&amp;gt;&amp;gt;&amp;gt; directors[::-1][&#39;kubrick&#39;, &#39;bigelow&#39;, &#39;spielberg&#39;, &#39;jenkins&#39;]  List Comprehensions          [&amp;lt;expression&amp;gt; for &amp;lt;element&amp;gt; in &amp;lt;sequence&amp;gt; if &amp;lt;conditional&amp;gt;]      &amp;gt;&amp;gt;&amp;gt; [x * x - 3 for x in [1, 2, 3, 4, 5] if x % 2 == 1][-2, 6, 22]&amp;gt;&amp;gt;&amp;gt; [i ** 2 for i in [1, 2, 3, 4] if i % 2 == 0][4, 16]First check the if statement with x from the List [1, 2, 3, 4, 5], then apply with x * x -3.  Linked Lists          recursive object only stores 1) its first value 2) a reference to the rest of the list, which is another linked list.      Linked lists are a list of items pointing to their neighbors. Notice that there’s no explicit index for each item.      In Python, if want to add an item at the head of the list, must create a new list and move all the items in the new list. With a linked list, the neighbor of the new item is the old beginning of the list.      To get an Index from the built-in list: lst[x] with x is the index. But with the linked list must start at the first item, then repeatedly follow the rest attribute, e.g. link.rest.rest.first.      class Link:    empty = ()    def __init__(self, first, rest=empty):        assert rest is Link.empty or isinstance(rest, Link)        self.first = first        self.rest = rest    def __repr__(self):        if self.rest is not Link.empty:            rest_repr = &#39;, &#39; + repr(self.rest)        else:            rest_repr = &#39;&#39;        return &#39;Link(&#39; + repr(self.first) + rest_repr + &#39;)&#39;    def __str__(self):        string = &#39;&amp;lt;&#39;        while self.rest is not Link.empty:            string += str(self.first) + &#39; &#39;            self = self.rest        return string + str(self.first) + &#39;&amp;gt;&#39;  enumerate()# normal for-statement&amp;gt;&amp;gt;&amp;gt; i = 0&amp;gt;&amp;gt;&amp;gt; seq = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]&amp;gt;&amp;gt;&amp;gt; for element in seq:...     print i, seq[i]...     i += 1... 0 one1 two2 three# wih enumerate()&amp;gt;&amp;gt;&amp;gt; seq = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]&amp;gt;&amp;gt;&amp;gt; for i, element in enumerate(seq):...     print i, element... 0 one1 two2 three      Trees              from sklearn import tree      consider recursion, a tree is a recursive abstract data type that has a lable and branches      remove a label use remove()      root: the node at the top of the tree, e.g. 7      label: the value in a node, selected by the label() function, up layer, e.g. all of the integers are values of this picture      branch: a subtree of the root, selected by the branches() function, under layer, e.g. 1      leaf: a node that has no branches, the lowst layer,  e.g. -4, 0, 6, 17, 20      depth: how far a node is from the root. e.g. the node 19 has depth 1 and the node 3 has depth 2      height: the depth of the lowest leaf, e.g. the nodes -4, 0, 6 and 17 are lowest leaves, which means they have depth 4 and the entire tree has height 4      some examples:      # The Tree-ADTs# Initial a treedef tree(label, branches=[]):    for branch in branches:      assert is_tree(branch), &#39;branches must be trees&#39;    return [label] + list(branches)# Define the labeldef label(tree):    return tree[0]# Define the branches def branches(tree):    return tree[1:]# Check is tree or not def is_tree(tree):    if type(tree) != list or len(tree) &amp;lt; 1:      return False    for branch in branches(tree):      if not is_tree(branch):        return False    return True# Check is tree or not def is_leaf(tree):    return not branches(tree) # Print the treedef print_tree(t, indent=0):    print(&#39;  &#39; * indent + str(label(t)))    for b in branches(t):      print_tree(b, indent + 1)    # -------------------------- Some Solutions -------------------------- ## Calculate the Height of Treedef height(t):    if is_leaf(t):          return 0      return max([height(branch) for branch in branches(t)]) + 1# find the max value of the treedef tree_max(t):    if is_leaf(t):        return label(t)    else:        return max([label(t)] + [tree_max(branch) for branch in branches(t)])# find the path that has max sumdef max_path_sum(t):    if is_leaf(t):        return label(t)    else:        return max([max_path_sum(branch) for branch in branches(t)]) + label(t)# square all value of the treedef square_tree(t):    return tree(label(t)**2, [square_tree(branch) for branch in branches(t)])# find the path that has value x, and x can be listdef find_path(tree, x):    if label(tree) == x:        return [label(tree)]     for b in branches(tree):        path = find_path(b, x)         if path:            return [label(tree)] + path  zip(first_iter, second_iter)          Iterate over co-indexed (x,y) pairs. Return a list with tuple from lists      by differen length, return the short one      zip((iterable, ....))      &amp;gt;&amp;gt;&amp;gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&amp;gt;&amp;gt;&amp;gt; b = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]&amp;gt;&amp;gt;&amp;gt; list(zip(a,b))[(&#39;a&#39;, &#39;1&#39;), (&#39;b&#39;, &#39;2&#39;), (&#39;c&#39;, &#39;3&#39;), (&#39;d&#39;, &#39;4&#39;)]  Dictionaries          Quick even with Key increase      More memory      Space trade time      HashTable      &amp;gt;&amp;gt;&amp;gt; table = {}&amp;gt;&amp;gt;&amp;gt; test1 = &#39;abc&#39;&amp;gt;&amp;gt;&amp;gt; test2 = &#39;123&#39;# put &#39;test2&#39; into table with label &#39;test1&#39;&amp;gt;&amp;gt;&amp;gt; table[test1] = [test2]&amp;gt;&amp;gt;&amp;gt; table{&#39;abc&#39;: [&#39;123&#39;]}&amp;gt;&amp;gt;&amp;gt; dict([(3, 9), (4, 16), (5, 25)]){3: 9, 4: 16, 5: 25}# Example from LeetCode #1 Two Sumdef two_sum(nums, target):    dic = {}                                # initial a dic    for i, num in enumerate(nums):                      targ_num = target - num             # calc difference between targ and current value        if targ_num in dic:                 # if the difference already in dic            return [dic[targ_num], i]       # direct return the index of both nums         dic[num] = i                        # otherwise save the num in dic for next search  Non-Local and Global Assignment          nonlocal &amp;lt;var_name&amp;gt;: defines outer function, which means only use it if there’s a inside function. Otherwise should use global &amp;lt;var_name&amp;gt;      place in top of inner function      def outer_func():    a = 1               # Initial a = 1        # 1) Normal     def inner_func1():        a = 2           # Update a = 2, irrelevant with `a = 1` above         print(a)        # -&amp;gt; 2    inner_func()              print(a)            # -&amp;gt; 1, print a under `outer_func()` out        # 2) UnboundLocalError    def inner_func2():        print(a)        # -&amp;gt; Error! Call `a` which didn&#39;t initialize yet         a = 2           # Initial    inner_func()          print(a)        # 3) with `nonlocal`    def inner_func3():        nonlocal a      # def a is a variabl from outside function `outer_func()`        print(a)        # -&amp;gt; 1, here is `a` from outside        a = 2           # Update a = 2      inner_func()          print(a)            # -&amp;gt; 2a = 1               # Initial a = 1def func():    global a        # def that a is global, which means inside this function is `a = 1`    print(a)        # -&amp;gt; 1, here is `a` from outside    a = 2           # Update a = 2  inner_func()      print(a)            # -&amp;gt; 2  Iterators          iter(iterable): Return an iterator over the elements of an iterable value      next(iterator): Return the next element in an iterator      print out an element in the list and remove it from the list at same time        Built-in functions for Iteration          map(func, iterable): Iterate over func(x) for x in iterable      filter(func, iterable): Iterate over x iterable if func(x)      reversed(sequence): Iterate over all the elements in a sequence in reverse order      list(iterable): Create a list containing all the elements in the input iterable      tuple(iterable): Creates a tuple containing all the elements in the input iterable      sorted(iterable): Creates a sorted list containing all the elements in the input iterable        Generators and Generator Functions          yield var_name: iterable ‘return’      A generator function is a function that yields values insted of returning them. And can yield multiple times. Pro: save the CPU.      yield from: will yield all values from an iterator or iterable, e.g. a list.      &amp;gt;&amp;gt;&amp;gt; def foo():...     print(&quot;starting...&quot;)...     while True:...             res = yield 4...             print(&quot;res:&quot;, res)&amp;gt;&amp;gt;&amp;gt; g = foo()&amp;gt;&amp;gt;&amp;gt; print(next(g))			starting...4&amp;gt;&amp;gt;&amp;gt; print(next(g))res: None4      Line 8: invoke print(next(g)), the foo() function starts executing. First invoke line 2 print(&quot;starting...&quot;) then get into the while. Finally at line 4 meet yield, so return 4. The process stopped. The line 5 print(&quot;res:&quot;, res) will not executed. So showing line 9 and 10, but remember the state of the function for future nextcalls.        Line 11: invoke print(next(g)) again. But this time starts after the yield that was previously executed, which is line 4 to give res the value, but the right side of = has no value, because the 4 already returned. So showing line 12 with res: None.  Then run until the next yield statement.        The process will continue to execute in the while-loop and meet yield again. At this time, it will returns 4 and then the process stops.    Object Oriented Programming (OOP)          class: a template for creating objects, e.g. Car      instance: a single object created from a class, e.g. my_car = Car(&#39;red&#39;) and my_car is an instance of the Car class      attribute: a property of an object, specific to an instance. A variable that belongs to the class, e.g. self.wheels and self.color. Invoke: my_car.wheels and `    my_car.color`      class attribute: a property of an object, shared by all instances of a class                  Accessing Attributes: getattr(&amp;lt;name&amp;gt;, &#39;var&#39;) and hasattr(&amp;lt;name&amp;gt;, &#39;var&#39;)          e.g. num_whells                    method: an action (function) that all instances of a class may perform, e.g. drive and pop_tire. Invoke: my_car.drive()      constructor: how to build an instance of the class. __init__ is called with the new object as its first argument (named self), along with any additional arguments.      class Car(object):															 # class    num_wheels = 4	      def __init__(self, color):										# constructor         self.wheels = Car.num_wheels						   # attricute        self.color = color    def drive(self):															# method        if self.wheels &amp;lt;= Car.num_wheels:            return self.color + &#39; car cannot drive!&#39;        return self.color + &#39; car goes vroom!&#39;    def pop_tire(self):        if self.wheels &amp;gt; 0:            self.wheels -= 1        # ------------------------- Some Tests ------------------------- #&amp;gt;&amp;gt;&amp;gt; my_car = Car(&#39;red&#39;)														# instance&amp;gt;&amp;gt;&amp;gt; my_car.color																 # invoke the attribute &#39;red&#39;&amp;gt;&amp;gt;&amp;gt; my_car.wheels4&amp;gt;&amp;gt;&amp;gt; my_car = Car(&#39;red&#39;)&amp;gt;&amp;gt;&amp;gt; my_car.drive()																# invoke the method&#39;red car goes vroom!&#39;  Inheritance: to reduce the repeated code.          class &amp;lt;name&amp;gt;(&amp;lt;base class&amp;gt;):      # ------------------------- Original ------------------------- #class Dog():    def __init__(self, name, owner):        self.is_alive = True         self.name = name         self.owner = owner             def eat(self, thing):        print(self.name + &quot; ate a &quot; + str(thing) + &quot;!&quot;)             def talk(self):        print(self.name + &quot; says woof!&quot;)class Cat():    def __init__(self, name, owner, lives=9):        self.is_alive = True         self.name = name         self.owner = owner         self.lives = lives         def eat(self, thing):        print(self.name + &quot; ate a &quot; + str(thing) + &quot;!&quot;)         def talk(self):        print(self.name + &quot; says meow!&quot;)To avoid redefining attributes and methods for similar classes use superclass from which the similar classes inherit. For example, create a class Pet and redefine Dog as a subclass of Pet.# ------------------------- Inheritance ------------------------- #class Pet():    def __init__(self, name, owner):        self.is_alive = True            self.name = name         self.owner = owner             def eat(self, thing):        print(self.name + &quot; ate a &quot; + str(thing) + &quot;!&quot;)             def talk(self):        print(self.name)class Dog(Pet):    def talk(self):        print(self.name + &#39; says woof!&#39;)                # ------------------------- Some Tests ------------------------- #       &amp;gt;&amp;gt;&amp;gt; dog = Dog(&#39;doggy&#39;,&#39;my&#39;)&amp;gt;&amp;gt;&amp;gt; dog.name									# invoke variable&#39;doggy&#39;&amp;gt;&amp;gt;&amp;gt; dog.owner&#39;my&#39;&amp;gt;&amp;gt;&amp;gt; dog.eat(&#39;meat&#39;)						 # invoke methoddoggy ate a meat!&amp;gt;&amp;gt;&amp;gt; dog.talk()doggy says woof!  Order of Growth (time):          Exponential growth, incrementing n multiplies time by a constant: $O(b^n)$      Quadratic growth, incrementing n increases time by n times a constant: $O(n^2)$      Linear growth, incrementing n increases time by a constant: $O(n)$      Logarithmic growth, doubling n only increaments time by a constant: $O(\\mathrm{log} \\, n)$      Constant growth, increasing n doesn’t affect time: $O(1)$        Str and Repr:          Both are built-in functions. Be invoked by calling repr(obj) or str(obj) rather than obj.__repr__() or obj.__str__().      str(): “Human-readable” form      repr(): “Computer-readable” form        Example for Iterable:# Does every element equal some other element?def all_have_an_equals(s):  &quot;&quot;&quot;  &amp;gt;&amp;gt;&amp;gt; all_have_an_equals([4, 3, 2, 3, 2, 4])  True  &quot;&quot;&quot;  return all([s[i] in s[:i]+s[i+1:] for i in range(len(s))])Example take s[i]=s[1]=3, we cann see s[:i]=4 + s[i+1:]=[2, 3, 2, 4] = [4, 2, 3, 2, 4] without [3]. So simply use for-loop to checke if there has same element in the list as s[i].# V2def all_have_an_equals(s):  return min([s.count(x) for x in s]) &amp;gt; 1The simply version, count if a element x comes at least twice.  SQLSelect the Informations (colums) from tables:-- format: choose an attribut / column from the table SELECT [columns] FROM [table];-- choose two columns with &quot;,&quot; SELECT [column1], [column2] FROM [table];-- choose all the columnsSELECT * FROM [table];Conditions:-- format, conditions after WHERESELECT [column] FROM [table] WHERE [conditions] ORDER BY [order];-- two conditionsSELECT [column] FROM [table] WHERE [condition1] OR [condition2];-- e.g. individual order by using `ORDER BY (CASE ... WHEN ... THEN 1 ... END)`CREATE TABLE shopping_list ASSELECT name, store FROM products, lowest_prices WHERE name = item GROUP BY category HAVING MIN(MSRP/rating) ORDER BY (CASE category WHEN &quot;games&quot; THEN 1 WHEN &quot;phone&quot; THEN 2 ELSE 3 END); Insert datas:-- formatINSERT INTO [table] (column1, column2, ...) VALUES (value1, value2, ...);-- one table has contact with other tables, which means one attribut belongs to several tablesINSERT INTO [table] (column1, column2, ..., other_column) VALUES (value1, value2, ..., other_value);Delete the data:-- formatDELETE FROM [table] WHERE [conditions];Change the data:-- formatUPDATE [table] SET [column = new_data] WHERE [conditions];Create a table:  UNION join rows together  AS give a name of column-- formatCREATE TABLE [table_name] ASSELECT [val1] AS [column1], [val2] AS [column2],... UNION	SELECT [val3]						 , [val4] AS          ,...;		   -- orSELECT [expression] AS [name];-- or SELECT [expression] AS [name], [expression] AS [name];Delete the attribut:  Do not delete the data, just change the value to default null.UPDATE [table] SET [column = null] WHERE [conditions];Search for data with key words:-- search attribut with &quot;ABC&quot;, e.g. &quot;11ABC11&quot; can also befind.SELECT [column] FROM [table]WHERE ([column] LIKE &#39;%ABC%&#39;);Joins:  To select data from multiple tables.  LIMIT [limit] limits the number of rows in the output table-- formatSELECT [columns] FROM [table1], [table2], ... WHERE [conditions] ORDER BY [columns] LIMIT [limit];-- two tables share a column nameSELECT [columns] FROM [table] WHERE [conditions] ORDER BY [order]; -- When joining table names where column names are the same, use dot notation to distinguish which columns are from which table: use [table_name].[column_name]SELECT &amp;lt;[alias1].[column name1], [alias2].[columnname2]...&amp;gt;FROM &amp;lt;[table_name1] AS [alias1],[table_name2] AS [alias2]...&amp;gt; ...-- e.g.CREATE TABLE matchmaker ASSELECT a.pet, a.song, a.color, b.color FROM students AS a, students AS b    WHERE a.time &amp;lt; b.time AND a.pet = b.pet AND a.song = b.song;-- e.g.-- All dogs with parents ordered by decreasing height of their parentCREATE TABLE by_parent_height ASSELECT a.child FROM parents AS a, dogs AS bWHERE a.parent = b.name ORDER BY -b.height;   -- sort from high to low with &quot;-&quot;Operators  comparison operators: =, &amp;gt;, &amp;lt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt; or !=  boolean operators: AND, OR  arithmetic operators: +, -, *, /  concatenation operator: || to concatenate two strings into onePython  call in the terminal: sqlite3 -init name.sql  use namedtuple funktion form the collections package to create a table  use product funktion form the itertools package to merge all combinations of rows in the input tablesimport sqlite3db = sqlite3.Connection(&quot;name.db&quot;)db.execute(&quot;Syntax of SQL&quot;)      Aggregate Functions                  use syntax like max(), avg(), count() etc.                    Grouping Rows            -- FormatSELECT [columns] FROM [table] GROUP BY [expression] HAVING [expression];-- e.g. search for the average price of each category (by using &quot;GROUP BY&quot;)CREATE TABLE average_prices ASSELECT category, AVG(MSRP) AS average_price FROM products GROUP BY category; -- e.g. search for best deal (min(MSRP/rating) and the store to buy it CREATE TABLE shopping_list ASSELECT name, store FROM products, lowest_prices WHERE name = item GROUP BY category HAVING MIN(MSRP/rating);3.2 Examples  Some Examples from lab02:          full cases see here      def cycle(f1, f2, f3):    def func1(n):                                 # first to give is n times        def func2(x):                             # second to give is x            run = n                               # run n times             order = 1                             # f1, f2, f3            result = x            if run:                while run:                    if order == 1:                        result = f1(result)                    elif order == 2:                        result = f2(result)                    elif order == 3:                        result = f3(result)                    order = order % 3 + 1         # f1 -&amp;gt; f2 -&amp;gt; f3 -&amp;gt; f1                    run -= 1            return result        return func2    return func1To run this function i.e. my_cycle = cycle(add1, times2, add3)(2)(1):1) inside function cycle has input f1, f2, f32) then has inside function func1(n) and func2(x) which in this case n = 2 and x = 1, cause func1 first defined.Alternative i.e.&amp;gt;&amp;gt;&amp;gt; my_cycle = cycle(add1, times2, add3)&amp;gt;&amp;gt;&amp;gt; add_one_then_double = my_cycle(2)&amp;gt;&amp;gt;&amp;gt; add_one_then_double(1)4  Some Examples from project cats:          full cases see here      # ----------------------------------------- Q1 ---------------------------------- #def choose(paragraphs, select, k):    # Check the List with full Indexs    for i in range(len(paragraphs)):        if select(paragraphs[i]):            # Check the corrected Index with right order            if k == 0:                return paragraphs[i]            k -= 1    return &#39;&#39;1) Index must be corrected, it’s like ‘remove’ all the False Index2) In this case used two different Index Systems to locate the correct one# ----------------------------------------- Q2 ---------------------------------- #def about(topic):    assert all([lower(x) == x for x in topic]), &#39;topics should be lowercase.&#39;    # BEGIN PROBLEM 2    &quot;*** YOUR CODE HERE ***&quot;    # Use Higher-Order Function    def check(x):        # remove punctuations, lowercase of sentence then split via utils.py        x = split(lower(remove_punctuation(x)))        # use double for-statement to find the same key word        for i in topic:            # same as topic[i] == x[k]:            if i in x:                return True        return False    return check# ----------------------------------------- Q6 ---------------------------------- #def shifty_shifts(start, goal, limit):    diff = abs(len(start)-len(goal))    # version 1:     count = 0    # Question required    if count &amp;gt; limit:        return limit + 1    # return diff_length + total     if len(start) == 0 or len(goal) == 0:        return count + diff    # count the different chars    if start[0] != goal[0]:        count += 1    # recursion: use [1:] -&amp;gt; by running every time the length of string will -1    # + count, cause will reset as 0 every time    return shifty_shifts(start[1:], goal[1:], limit) + count    # version 2:     def counting(start, goal, limit, count):        if count &amp;gt; limit:            return limit + 1        if len(start) == 0 or len(goal) == 0:            return count + diff        if start[0] != goal[0]:            count += 1        return counting(start[1:], goal[1:], limit, count)    return counting(start, goal, limit, 0)There’s two version to solve this question1) return the correct answer for tests, but didn’t pass the ok.py, can’t figured out why2) use Higher-Order function pass the ok.py# ----------------------------------------- Q7 ---------------------------------- #def pawssible_patches(start, goal, limit):    &quot;&quot;&quot;A diff function that computes the edit distance from START to GOAL.&quot;&quot;&quot;    # similar as shifty_shifts    def counting(start, goal, limit, count):        diff = abs(len(start)-len(goal))        if count &amp;gt; limit:            return limit + 1        # if one is empty, should change n times of lengh another word which is diff        if len(start) == 0 or len(goal) == 0:            return count + diff        # if same char, skip with next char        if start[0] == goal[0]:            return counting(start[1:], goal[1:], limit, count)        # minimize the amount        return min(counting(start[1:], goal[1:], limit, count+1),         counting(start[1:], goal, limit, count+1), counting(start, goal[1:], limit, count+1))        return counting(start, goal, limit, 0)If there’s different char, there’s three conditions:1) compare with same index2) /3) compare with one word each time, maybe a[1] == b[0] or a[0] == b[1], e.g. a, b = &quot;ckiteus&quot;, &quot;kittens&quot;# ----------------------------------------- Q8 ---------------------------------- #def report_progress(typed, prompt, user_id, send):    i = 0    for k in typed:        # located the first incorrect word        if k != prompt[i]:            break        i += 1    # calculate the error ratio    progress = i / len(prompt)    # send --&amp;gt; &quot;print&quot;    send({&#39;id&#39;: user_id, &#39;progress&#39;: progress})    return progress # ----------------------------------------- Q9 ---------------------------------- #def time_per_word(times_per_player, words):    # Initial 2D-Array    # times[i][j] with player i (num) and index of word j (num)    times = [[0 for i in range(len(j)-1)] for j in times_per_player]    i = 0    for layer1 in times_per_player:        # first value represents the initial starting time        j = 0        for layer0 in layer1:            if j != 0:                # e.g. times[0][0] = times_per_player[0][1] - times_per_player[0][0]                #                  = 4 - 1 = 3                times[i][j-1] = layer0 - layer1[j-1]            j += 1        i += 1    # change the order as rrequested    return game(words, times)# ----------------------------------------- Q10 ---------------------------------- #def fastest_words(game):    player_indices = range(len(all_times(game)))  # contains an *index* for each player    word_indices = range(len(all_words(game)))    # contains an *index* for each word    # see exmaple with time() by Q9    # Initial a empty Array    result = [[] for i in player_indices]    # begin with compair for word 0 with different players     for word in word_indices:        for player in player_indices:            # default set the player 0 is always the winner            # in the case of a tie, the player 0 wins             if player == 0:                winer = 0                # set the player&#39;s time as minimum                min_time = time(game, player, word)            # save the current time            cur_time = time(game, player, word)            # reset the minimum time             if cur_time &amp;lt; min_time:                min_time = cur_time                winer = player        # add the word in the array        result[winer] += [word_at(game, word)]    return result   Some Examples from lab05:          full codes see here      # ------------------------------------- Q5 ------------------------------------- #def berry_finder(t):    if label(t) == &#39;berry&#39;:        return True    # if branch is empty, return False, cause the label already checked     if is_leaf(t):        return False    # get into every branches    for i in branches(t):        # use recursion to locate all labels every leaves        if berry_finder(i):            return True    return False# ------------------------------------- Q6 ------------------------------------- #def sprout_leaves(t, leaves):    # use recursion --&amp;gt; into lowest leaves that branch is empty (leaf)    # if branch is empty, add the leaves    if is_leaf(t):        # the &#39;label()&#39; here is now the &#39;lowest&#39; leaves, simply use (label(), [xx]) to print it out         return tree(label(t), [tree(i) for i in leaves])    # similar as Q5    return tree(label(t), [sprout_leaves(i, leaves) for i in branches(t)])A tricky one# ------------------------------------- Q10 ------------------------------------- #def add_trees(t1, t2):    # use ADT and recursion    length1, length2 = len(branches(t1)), len(branches(t2))    # 1) if both trees have same number of branches:    if length1 == length2:        # use zip() to iterate over multiple sequences at once          return tree(label(t1) + label(t2), [add_trees(b1, b2) for b1, b2 in zip(branches(t1), branches(t2))])    # 2) if both trees have different number of branches:    elif length1 &amp;lt; length2:        # add n (different length of both trees) branches with value 0 to short tree        new_branches = branches(t1) + [tree(0) for _ in range(length2 - length1)]        # reset the new tree        new_tree = tree(label(t1), new_branches)        return add_trees(new_tree, t2)    else:        # if tree2 is smaller than tree1, just exchange the input place         # and below condition &#39;elif&#39; works too        return add_trees(t2, t1)The idea of the solution for this question can split into two parts:      if both trees have same number of branches: add the roots label() of both trees directly, then for branches() via recursion, and because of that the next iteration: branches() —&amp;gt; new label()        if both trees have different number of branches: this is the tricky part! Because of the different number of branches() (the length), part one will only add the lowest leaves. The simplest way may add the different of brauches() with value 0 for the short tree, so now they both have same branches().    Some Examples from hw03:          full codes see here       # ------------------------------------- Q4 ------------------------------------- # def replace_leaf(t, find_value, replace_value):     # use recursion into leaf     if is_leaf(t):         if label(t) == find_value:             # replace the leaf value if matched              return tree(replace_value)         # return the leaf value if didn&#39;t matched          return t     temp_branch = []     # let branches into recursion to located the leaf      for b in branches(t):         # storage the value every recursion         temp_branch += [replace_leaf(b, find_value, replace_value)]     return tree(label(t), temp_branch)For case like this, its usefull to via recursion to get into the leaf by is_leaf() then label it. The recursion is relate to branches.  Some Examples from lab06:          full codes see here      # -------------------------------------- Q1 -------------------------------------- #def make_fib():    pre, pro = -1, 1    def count_fib():        nonlocal pre, pro        fib = pre + pro        pre = pro        pro = fib        return fib    return count_fib    # -------------------------------------- Q4 -------------------------------------- #def insert_items(lst, entry, elem):    new_lst = lst    flag = 0    for i, num in enumerate(lst):        # additional conditions flag to avoid stuck in the loop        if num == entry and flag == 0:            # insert the value in position i + 1            new_lst.insert(i+1, elem)            # update flag with continue to get out of loop            flag = 1            continue        flag = 0    return new_lstQ4: for case with quivalent value from entry and elem could caused the infinitely long list, e.g. [1, 4, 8] with entry, elem = 4, 4. That is because insert 4 after 4, then for next loop checked the second 4 again, and so on. Thats why should add two additional conditions flag and continue to avoid this issue. Only one of them will not work. With flag = 1 avoid get into the if condition and with continue to skip the current iteration.  Some Examples from hw04:          full codes see here      # ------------------------------ Q3 ------------------------------ #def repeated(t, k):    assert k &amp;gt; 1    # iter(): for-loop works like next()    count = 1    pro = 0    for i in t:        pre = i             # mark the current value        if pre == pro:      # if the pre and pro value are the same            count += 1            if count == k:  # appears k times in a row                 return i        else:            count = 1       # reset, if interrupted         pro = pre                   # ------------------------------ Q4 ------------------------------ #def permutations(seq):    # use recursion to get into the single value    # use yield to invoke the function to get all the order     if len(seq) == 1:        yield seq               else:        # let the rest into next iteration, begin with the last one due to recursion         for i in permutations(seq[1:]):               for k in range(len(i)+1):                lst = list(i[:])        # initial a list with current value(s)                # add the pre-position value, [0] from last iteration due to [1:]                 lst.insert(k, seq[0])                    yield lst  Some Examples from lab07:          full codes see here      # This is a method from the class ProfessorCarddef effect(self, other_card, player, opponent):        orig_opponent_deck_length = len(opponent.deck.cards)        # adds the power of the opponent&#39;s card to all of mine         for my_card in player.deck.cards:            my_card.attack += other_card.attack            my_card.defense += other_card.defense        # if a card in deck have same power as the opponent&#39;s card remove it        for card in opponent.deck.cards[:]:             # copy the deck            if card.attack == other_card.attack \\                or card.defense == other_card.defense:  # Check if same power                opponent.deck.cards.remove(card)        # remove the card         discarded = orig_opponent_deck_length - len(opponent.deck.cards)        if discarded:            print(&#39;{} cards were discarded from {}\\&#39;s deck!&#39;.format(discarded, opponent.name))            return          # Copy a list &amp;gt;&amp;gt;&amp;gt; lst = [1, 2, 3, 4]&amp;gt;&amp;gt;&amp;gt; copy = lst[:]&amp;gt;&amp;gt;&amp;gt; copy[1, 2, 3, 4]&amp;gt;&amp;gt;&amp;gt; copy is lstFalseCopy a list to avoid trouble when mutate a list as iterating through it. In line 11 directly used the copy opponent.deck.cards[:] with for-loop.Some Examples from hw05:  full codes see here  A tree is a binary search tree (BST) if:          Each node has at most two children (branches), which means a leaf is automatically a valid BST      The children are valid binary search trees, which means both side of the tree must be BST      For every node, node’s left child are less than or equal to the label of the node      For every node, node’s right child are greater than the label of the node      If theres only one child, so it can consider as left or right, which means theres no rules, it’s automatically a BST      def is_bst(t):    # search for the minimum of the right child (branches)    def bst_min(t):        if t.is_leaf():            return t.label        return min(t.label, bst_min(t.branches[0]))    # search for the maximum of the left child (branches)    def bst_max(t):        if t.is_leaf():            return t.label        return max(t.label, bst_max(t.branches[0]))    if t.is_leaf():             # a leaf is automatically a bst        return True    if len(t.branches) == 1:    # if only one child        return True                     if len(t.branches) == 2:		# max 2 children      	# 1) the label greater than or equal to all nodes on the left branches and        # smaller than all nodes on the right branches         # 2) both children are BST        if (bst_max(t.branches[0]) &amp;lt;= t.label &amp;lt; bst_min(t.branches[1]) and         is_bst(t.branches[0]) and is_bst(t.branches[1])):                return True    return FalseUsed two helper functions bst_max() and  bst_min() to find the max and the min of the left and right branches. So if the label is bigger than the max of the left and smaller than / equal to the min of the right branches, it’s a BST. The helper function used the recursion to locate the min / max value, if didn’t find it until the leaf, so the leaf is the min / max value. To be clear: branches[0] is the left side and branches[1] is the right side.  Some Examples from lab08:          full codes see here      # -------------------------------------- Q3 -------------------------------------- # &quot;&quot;&quot;remove the odd-indiced (0-based) elements from a linked list, if only one elment, return it directly&quot;&quot;&quot;def every_other(s):    # while s != s.empty and s.rest != empty     # -&amp;gt; if only one element, will not get into the loop    while s and s.rest:                     s.rest = s.rest.rest        # remove the odd index (0-based)        s = s.rest                  # let the rest elements into the loopLinked list has no len() or index, so just “replace” the odd one with others. Set the loop condition with and so if a linked list has only one elment will not get into the loop.# -------------------------------------- Q4 -------------------------------------- # &quot;&quot;&quot;Mutates t so that each node&#39;s label becomes the product of all labels in the corresponding subtree rooted at t.&quot;&quot;&quot;def cumulative_mul(t):    if t.is_leaf():             # if get the leaf, return nothing        return    for b in t.branches:                cumulative_mul(b)       # let the branches into the recursion        t.label *= b.label      # product of layer by layer Use the recursion and definition of branches, multiply layer by layer. Line 8 make sure every time only calculate the “new” label from the “new” Tree with is the branches, it’s like stairs.# -------------------------------------- Q5 -------------------------------------- # &quot;&quot;&quot;The idea is to check whether a link contains a cycle.&quot;&quot;&quot;# version 1def has_cycle(link):    # similar as Q2 (except Line 9!)    lst = []                # create a list to save the passed link    while link:        if link in lst:     # if list contains the link, return True                     return True        lst.append(link)    # save the linked list in the list, thinking about two pointer!        link = link.rest    # let the rest of the linked list in the loop    return False # Version 2 with constant space def has_cycle_constant(link):    # two pointers     if not link:                                    # if is empty, return False        return False    slow, fast = link, link.rest                    # define two ponters     while fast:                                     # while not empty        # if fast is empty, which means no more elements to compair        if not fast.rest:                                       return False        # if both pointers contain each other        # which means, fast one catch up the slow one by one more cycle        elif fast is slow or fast.rest is slow:     # compair two steps, faster                 return True        else:                                       # let rest elements into loop                                                       slow, fast = slow.rest, fast.rest.rest  # let fast one two steps faster, otherwise too slow    return FalseVersion 1: The idea of the solution is to create a list to save all linked list went through the loop. By next loop will only save the rest of the linked list. Eventuell has this list a whole variante of the linked list. Similar like two pointer. If the linked list is a cycle, it will find the same part of the elements in the list.  e.g. by first run: original link = [1 2 3 / 1 2 3 / 1 2 3 ....], lst = [1 2 3 / 1 2 3 / 1 2 3/ ...] $\\neq$ link = [2 3 / 1 2 3 / 1 2 3 ....]. By 2. run: lst = [1 2 3 /... 2 3 / 1 2 3 ...] $\\neq$ link = [3 / 1 2 3 / 1 2 3 ....]. By 3. run: lst = [1 2 3 /... 2 3 / 1 2 3 .../ 3 / 1 2 3 ....] $=$ link = [1 2 3 / 1 2 3 ....]. As the 3. run shows, the lst contains the link.Version 2: The idea is to create two pointers, one fast and one slow, eventuell compair them, if is the same then is cycled. Important is Line 29: two conditions to compair two steps, it’s faster. And Line 32, if the linked list is a cycle, so it’s getting there how ever it takes. So with fast.rest.rest can make it faster, analog can with fast.rest.rest.rest.# -------------------------------------- Q6 -------------------------------------- # &quot;&quot;&quot;Reverse labels every odd level of the tree.&quot;&quot;&quot;def reverse_other(t):    def subfunc(t, level):        if t.is_leaf():                         # if get the leaf, return nothing            return        if level:                               # if it&#39;s odd level -&amp;gt; need reversed              temp = []                           # create a temp list to store the labels            for b in t.branches:                # add all labels in the temp list,                temp.append(b.label)            temp.reverse()                      # then reverse it            for i in range(len(t.branches)):    # save the reversed label for each level              	t.branches[i].label = temp[i]   # in opposite position         for b in t.branches:                    # recursion for the next level            subfunc(b, not level)                   subfunc(t, False)                           # begin with the first level 0 -&amp;gt; even Just create a blank temp list to save all labels of odd level and reverse it, then replace it into the true tree. To locate the odd level, just simply use flag with True or False to marke it and starting by the even level with False.      Some Examples from lab09:                  full codes see here                    A full binary tree (FBT) is a tree with each node has either 0 or 2 branches (never 1 branch).            # -------------------------------------- Q3 -------------------------------------- #def num_trees(n):    if n == 1:        return 1    # 1) Catalan number with recursive formula: C_{n+1} = \\sum C_i * C_{n-i}    res = 0    for i in range(1, n):        res += num_trees(i) * num_trees(n - i)    return res    # 2) simplify the 1)    return num_trees(n-1) * (4*n-6)//nOne can consider that the FBT can be used with the Catalan number formula is if the left tree has 1 node, then the right tree must has n-1 nodes, which means there is f(1)*f(n-1) possibilies. Analog, if the left tree has 2 nodes, then the right tree must has n-2 nodes, so there is f(2)*f(n-2) possibilities. And so on we can use the formula f(i)*f(n-i), which is the Catalan number recursive formula.# -------------------------------------- Q10 ------------------------------------- ## insert a value in an index of a linked listdef insert(link, value, index):    if not index:                                   # to changed index is 0        link.rest = Link(link.first, link.rest)     # let the rest of linked list as new linked list        link.first = value                          # add the value in the index 0    elif link.rest is link.empty:                   # out of the range        print(&#39;IndexError&#39;)    else:         insert(link.rest, value, index-1)          # recursion with rest of linked listNote that a linked list has no length or index.Deep Linked List# -------------------------------------- Q11 ------------------------------------- ## Returns the deep length of a possibly deep linked listdef deep_len(lnk):    if lnk is Link.empty:        return 0    elif not isinstance(lnk, Link):            # the deepest (which is not a linked list)        return 1    else:        return deep_len(lnk.first) + deep_len(lnk.rest)     # split the list into the recursionThe idea is to split the list into the two lists and recurse on them (line 9). And if the list reaches the deppest, then lnk.first is not a linked list but a int, so can use isinstance(object, classinfo) to check if a object belongs to the classinfo, e.g. a = 5 then isinstance(a, int) is True. So at line 6, if reaches the deppest, then will return False, so the length is 1.# -------------------------------------- Q13 ------------------------------------- ## Prune the tree, keeping only the n branches of each node with the smallest label.def prune_small(t, n):    while len(t.branches) &amp;gt; n:                                  # prune tree until n branches        largest = max(t.branches, key = lambda t: t.label)      # compair the branches due to their label        t.branches.remove(largest)                              # remove the large branches    for b in t.branches:        prune_small(b, n)                                       # next leafUse remove() to remove the branches / labels. Line 5: The Branches of the trees are compaired with the largest being indicated by the label.False.      Some Examples from lab14:          full codes see here      # Split the list and return the number of ways the sum of the first list # is within d# ------------------------------------- Q4 -------------------------------------#def num_splits(s, d):    def subfunc(s, n):        if not len(s):              # the last index            if abs(n) &amp;lt;= d:         # sum of the first is within d                 return 1            else:                return 0        first, rest = s[0], s[1:]   # split the list        # forwards and backwards          return subfunc(rest, n + first) + subfunc(rest, n - first)    return subfunc(s, 0) // 2       Line 14: the order of the subsets does not matter, e.g. [1, 2], [3] and [3], [1, 2] are the same, so the result must // 2."
  }
  
]

