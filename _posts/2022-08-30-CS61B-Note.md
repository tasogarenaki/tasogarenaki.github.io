---
title: CS61B Note
author:
  name: Terry
  link: https://github.com/tasogarenaki
date: 2022-08-30 20:00:00 +0200
categories: [Note, CS]
tags: [note, java, cs61b]
math: true
mermaid: true

---




# 1 Introduction

- Set the course code

  1. Create a repository from GitHub

  2. Create a folder `A` on local 

  3. ```bash
     $ cd A
     $ git clone https://github.com/my_repository.git
     $ cd B (Folder inside A)
     $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git
     $ git pull skeleton master
     ```

  4. Move the `HelloWorld.java` and `HelloNumbers.java` that you previously created into the `lab1`directory.

  5. ```bash
     $ git add lab1/*
     $ git commit -m "completed first part of lab1"
     $ git push origin master
     ```

- IntelliJ IDEA (Every Time!)

  1. Open - Choose the project file (not CS61B)
  2. File - Project Structure - Libraries - + - Java - CS61B/library-sp18/javalib - OK - OK
  3. File - New Projects Setup - Structure - Project - SDK: choose one - OK - open a file - Setup SDK

- Debugger
  - Breakpoints (right click for the breakpoint conditional)
  - Stepping over: step by step
  - Stepping into: get into the method
  - Stepping out: get out of the method 
  - Resume

- Some shortcuts:

  - Run: control + option + R

- Some key syntactic features:

  - `public class`: all code lives inside of classes.

  - The code that is run is inside of a method called `main`, which is declared as `public static void main(String[] args)`.

    - `void`: It has no return type.
    - `main`: This is the name of the method.
    - `String[] args`: This is a parameter that is passed to the main method.

  - Use `{` and `}` to denote the beginning and the end of a section of code.
  - Statements must end with semi-colons `;`.
  - Comments with `/* */` or `//`.
  - Javadoc: `/** */` for methods or classes.
  - Compiler and Run Java program via Terminal:

    ```bash
      $ javac name.java
      $ java name
    ```

  - `static` type for all variables and expressions

    - Variables must be declared before it is used, and must have a specific type and the type can never change.
        - Let the programmer know exactly what sort of objekt is working with
        - No type erros

    ```java
      int x = 0;
      
      string x = "test";  // error
    ```

  - `System.out.print` will not print a newline (return), `System.out.println` will print a newline.

  - `@param` name a varialbe 

    ```java
    /**
    * @param variable name 
    * @param expected Expected double
    * 
    * or
    *
    * @param("name") String variable
    */
    ```


  - `static final` to declare any constans, e.g. the gravitational constant G

    ```java
    private static final double G = 6.67e-11;
    ```

  - `for-each` loop: to iterate through elements of arrays and collections

    ```java
    /* for (type var : array) { }; */
    int[] numArray = { 1, 2, 3, 4, 5, 6 };    
    
    for (int i : numArray) {      
      System.out.print(i);    
    }
    
    // -> 123456 
    
    /* is equivalent to: */
    int[] numArray = { 1, 2, 3, 4, 5, 6 };   
    
    for (int i = 0; i < numArray.length; i++) {      
      int j = numArray[i];	// j is i in first case   
      System.out.println(j);    
    }
    ```

- Functions:

  - Functions must be declared as part of a class. A function that is part of a class is method, so all functions are methods.
    - To define a function use `public static` (e.g. Python `def`).
    - All parameters of a functions must be declared.

  ```java
    public class LargerDemo {
        /** Returns the larger of x and y. */
        public static int larger(int x, int y) {
            if (x > y) {
                return x;
            }
            return y;
        }
    
        public static void main(String[] args) {
            System.out.println(larger(8, 10));
        }
    }
  ```

- Class

  - Examle:

    ```java
    /* Dog.java */
    public class Dog {		// non-static
        public int weightInPounds;		// instance variable 
        
        /* One integer constructor for dogs */
        public Dog(int w) {		// e.g. python def __init__
            weightInPounds = w;
        }
        
        public void makeNoise() {		// non-static method 
            if (weightInPounds < 10) {
                System.out.println("yip!");
            } else if (weightInPounds < 30) {
                System.out.println("bark");
            } else {
                System.out.println("wooof!");
            }
        }
    }
    
    /* DogLauncher.java */
    public class DogLauncher {		  // client of Dog class
        public static void main(String[] args) {
            Dog d = new Dog();			// Declaration a new variable of type Dog
            d.weightInPounds = 51;	// Instantiation
            d.makeNoise();				 // Invocation
        }
    }
    
    > javac Dog.java
    > javac DogLauncher.java
    > java DogLauncher
    wooof!
    ```

    - A class that uses another class is sometimes called a "client" of that class, i.e. `DogLauncher` is a client of `Dog`. 
    - Instance variables or non-static variables must be declared inside the class. 
    - The `makeNoise()` is a **non-static / instance** method, and do not have the `static` keyword. If the method is going to be invoked by an instance of the class, then it should be non-static. It means, if one method needs to use the instance variable, the method must be non-static.
      - To call the `makeNoise` method should using the `new` keyword to instantiate a `Dog`, then call `d.makeNoise()`.
    - The constructor with signature `public Dog(int w)` will be invoked anytime that we try to create a `Dog` using the `new` keyword and a single integer parameter. Similar to Python `__init__` method.
    
  - **Non-static** Methods are actions that can be taken only by a specific instance of a class. 

    ```java
    Math m = new Math();
    x = m.sqrt(100);
    ```

  - **Static** methods are actions that are taken by the class itself.

    ```java
    x = Math.sqrt(100);
    ```

  - Non-static:

    ```java
    public Dog maxDog(Dog d2) {	 // non-static method
        if (this.weightInPounds > d2.weightInPounds) {
            return this;	// use the keyword this to refer to the current object
        }
        return d2;
    }
    
    /* invoke */
    Dog d = new Dog(15);	
    Dog d2 = new Dog(100);
    d.maxDog(d2);
    ```

  - Static: 

    ```java
    public class Dog {
        public int weightInPounds;
        public static String binomen = "Canis familiaris";	// static variable
        ...
    }
    
    /* invoke */
    Dog.binomen
    ```

- Arrays of objects

  - use `new` keyword to create the array
  - use `new` again for each object that needs to put in the array

  ```java
  /* example 1 */
  Dog[] dogs = new Dog[2];		// Creates an array of Dogs of size 2
  dogs[0] = new Dog(8);			  // dog 1 has value of 8 
  dogs[1] = new Dog(20);
  dogs[0].makeNoise();			  // dog 1 invoke the method 
  
  /* example 2 */
  int[] name = new int[5];
  name[0] = 1;
  name[1] = 2; 
  
  /* example 3*/
  int[] myList = {1, 2, 3};
  ```

# 2. Lists

## 2.1 SLList (Singly Linked List)

```java
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

```java
public class SLList {
    public IntNode first;
    
    public SLList(int x) {
        first = new IntNode(x, null);
    }
    
    /** Adds x to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
    
  /** Returns the first item in the list. */
    public int getFirst() {
        return first.item;
    }
    
    public static void main(String[] args) {
        /* Creates a list of one integer, namely 10 */
      	SLList L = new SLList(10);
        L.addFirst(10);
        int x = L.getFirst();	// outputs 10
    }
}
```

- Public vs. Private

  ```java
  /* change public to private */
  private IntNode first;
  ```

  - Private variables and methods can only be accessed by code inside the same `.java` file, e.g. in this case `SLList.java`. Other class can not invoke `first`. But can through `public` methods like `public void addFirst` to invoke or edit `first`.

- Nested Class 

  - Put a class inside of another class. Do not need two java files. 
  - If the nested class has no need to use any of the instance methods or variables of enclosing class, then can declare with `static`. Which means that methods inside of static class can not access any of the members of the enclosing class.
  - e.g. `IntNode` class is depends on `SLList` class, so can put in inside of `SLList`

  ```java
  public class SLList { 
      private class IntNode {
          public int item;
          public Node next;
  
          public IntNode(int i, IntNode n) {
              item = i;
              next = n;
          }
      }
    
      public IntNode first;
      public SLList(int x) {
          first = new IntNode(x, null);
      }
      
      /** Adds an item to the front of the list */
      public void addFirst(int x) {
          first = new IntNode(x, first);
      }
      
      public int getFirst() {
          return first.item;
      }
      
      public static void main(String[] args) {
          SLList L = new SLList(15);
          L.addFirst(10);
          int x = L.getFirst();
      }
  }
  ```

  - addLast and size
  
    ```java
    /** Adds an itemto the end of the list. */
    public void addLast(int x){
      IntNote p = first;
      
      /* Move p until it reaches the end of the list. */
      while (p.next != null){
        p = p.next;
      }
      
      p.next = new IntNote(x, null);
    }
    
    /** helper function 
    	* Returns the size of the list that starts at IntNode p. */
    private static int size(IntNode p) {
        if (p.next == null) {
            return 1;
        }
        return 1 + size(p.next);
    }
    
    public int size() {
        return size(first);
    }
    ```
  
    - use `private static` for helper function, to define this function can not invoked by outside.
    - `addLast()` is slow. Because we have to start at the front, and loop all the way to the back of our list before adding our element.
  
  - **Sentinel Nodes:** 
  
    ```java
    /** Creates an empty SLList */
    public SLList(){
      sentinel = new IntNode(100, null);
      size = 0;
    }
    
    public SLList(int x){
      sentinel = new IntNode(100, null);
      sentinel.next = new IntNode(x, null);
      size = 1;
    } 
    
    public void addFirst(int x){
      sentinel.next = new IntNode(x, sentinel.next);
      size += 1;
    }
    
    public int getFirst(){
      return sentinel.next.item;
    }
    
    public void addLast(int x) {
        size += 1;
        IntNode p = sentinel;
      
        while (p.next != null) {
            p = p.next;
        }
    
        p.next = new IntNode(x, null);
    }
    ```
  
    - It's the first node and it's a dummy node, and not contains in the list.
    - It can be any number, because it will not be used. Its for `addLast`.
    - A `SLList` with a sentinel node has at least the following invariants:
      - The `sentinel` reference always points to a sentinel node.
      - The front item (if it exists), is always at `sentinel.next.item`.
      - The `size` variable is always the total number of items that have been added.
      - Inserting at the back of an SLList is much slower than the front.

## 2.2  DLList (Doubly Linked List)

- A node has a pointer to the next and the previous node. There's two way to implement it:

  1. Double Sentinel: There's a Sentinel Node at front and the end. `SentFront.next` is points to the first real Node, `prev` points to `null`. And `SentBack.next` points to `null`, `prev` points to the last real Node.

     <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/double_sentinel.png?raw=true" alt="double_sentinel" style="zoom:50%;" />

  2. Circular Sentinel: Only need one Sentinel Node, and this Sentinel Node `next` points to the first real Node, `prev` points to the last real Node. If there's no node, `next` and `prev` point to itself.

     <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/circular_sentinel.png?raw=true" alt="circular_sentinel" style="zoom:50%;" />

- Generic List: `<PLACEHOLDER>` after the class name. This allows the list to work not only for `int`, but also for i.e., `string` too.

  ```java
  /** Make a placeholder for this class, so you can declare the type later */
  public class DLList<HERE> {
      private IntNode sentinel;
      private int size;
  
      public class IntNode {
          public IntNode prev;
          public HERE item;
          public IntNode next;
          ...
      }
      ...
  }
  
  /** HERE is now Integer, so d1 is a int */
  DLList<Integer> d1 = new DLList<>(5);
  d1.insertFront(10);
  
  /** HERE is now String, so d2 is a String */
  DLList<String> d2 = new DLList<>("hello");
  d2.addLast("world");
  ```

  - int: Integer
  - double: Double
  - char: Character
  - boolean: Boolean
  - long: Long

## 2.3  AList (Array List)

- There are three valid notations for array creation
  - `y = new int[3];`
  - `x = new int[]{1, 2, 3, 4, 5};`
  - `int[] w = {9, 10, 11, 12, 13};`

- 2D Array

  ```java
  int[][] pascalsTriangle;					// declaration
  pasacalsTriangle = new int[4][];	// a 2D array contains four 1D array
  
  pascalsTriangle[0] = new int[]{1};// give a value at position 0
  
  int[][] matrix;
  matrix = new int[4][4];					 // four 2D array contain 5 int 1D array 
  
  /** all togher */
  int[][] pascalAgain = new int[][]{ {1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}};
  ```

- Alist:

  ```java
  public class AList<T> {
      private T[] items;
      private int size;
      
      /** Creates an empty list */
      public AList() {
        	/* Casts, if we want to use <T>: must new a Objetc 
             then transfer the arrys type */
          items = (T[]) new Object[100];
          size = 0;
      }
      
    	/** Resizes the underlying array to the target capacity */
      public void resize(int capacity) {
          T[] a = (T[]) new Object[capacity];
          System.arraycopy(items, 0, a, 0, size);
          items = a;
      }
      
      /** Inserts X into the back of the list */
      public void addLast(T x) {
          /* Resize items since its full */
          if (size == items.length) {
            /* faster */ 
            resize(size * 2); 
          }
          items[size] = x;
          size = size + 1;
      }
      
      /** Returns the item from the back of the list */
      public T getLast() {
          return items[size - 1];
      }
      
     	/** Deletes item from back of the list and returns deleted item */	
      public int removeLast() {
          int last = getLast();
        	/* not necessary */
          items[size-1] = null;	
          size = size - 1;
          return last;
      }
  }
  ```
  

## 2.4 Deque (Double ended queue)

<img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/deque.png?raw=true" alt="deque" style="zoom:50%;" />

- Specifically, any deque implementation must have exactly the following operations:
  - `public void addFirst(T item)`: Adds an item of type `T` to the front of the deque.
  - `public void addLast(T item)`: Adds an item of type `T` to the back of the deque.
  - `public boolean isEmpty()`: Returns true if deque is empty, false otherwise.
  - `public int size()`: Returns the number of items in the deque.
  - `public void printDeque()`: Prints the items in the deque from first to last, separated by a space.
  - `public T removeFirst()`: Removes and returns the item at the front of the deque. If no such item exists, returns null.
  - `public T removeLast()`: Removes and returns the item at the back of the deque. If no such item exists, returns null.
  - `public T get(int index)`: Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth. If no such item exists, returns null. Must not alter the deque!
  
- **Linked List Deque:**
  
  ```java
  /* Empty Linked List -> sentinel is a node with value null. */
  public LinkedListDeque() {
      sentinel = new Node<T>();
      sentinel.next = sentinel;
      sentinel.prev = sentinel;
      size = 0;
  }
  
  /* Adds an item to the front / back of the deque. */
  public void addFirst(T item) {
    Node<T> firstNode = new Node<T>(item);
    /* save the next node of sentinel in `next`, which should be pos 1. */
    Node<T> next = sentinel.next;
    /* copy `next`. */
    firstNode.next = next;
    /* points firstNode is the prev node of `next` */
    next.prev = firstNode;
    /* relocated the sentinel node */
    sentinel.next = firstNode;
    firstNode.prev = sentinel;
  
    size += 1;
  }
  
  public void addLast(T item) {
      Node<T> lastNode = new Node<T>(item);
      /* the prev node of the sentinel node points to the last node. */
      Node<T> prev = sentinel.prev;
  
      lastNode.prev = prev;
      prev.next = lastNode;
      sentinel.prev = lastNode;
      lastNode.next = sentinel;
  
      size += 1;
  }
  
  /* Prints the items in the deque from first to last. */
  public void printDeque() {
      for (Node<T> ptr = sentinel.next; ptr != sentinel; ptr = ptr.next) {
          System.out.print(ptr.item + " ");
      }
  }
  
  /* Removes and returns the item at the fonrt / back of the deque. */
  public T removeFirst() {
      return remove(sentinel.next);
  }
  
  public T removeLast() {
      return remove(sentinel.prev);
  }
  
  /* The helper function, see the grafic above */
  private T remove(Node<T> node) {
      if (size == 0) {
          return null;
      }
  
      Node<T> tempNext = node.next;
      Node<T> tempPrev = node.prev;
  
      tempPrev.next = tempNext;
      tempNext.prev = tempPrev;
      size--;
  
      return node.item;
  }
  ```
  
  - **Array Deque:** 
  
    - uses a circular array with two pointers head and tail. They both start at the same position, then the head pointer starts from back to front and the tail pointer from front to the end. If they meet again (head equals tail) it means the array is full.
  
    - Null is not allowed to add into the ArrayDeque.
    
    - `addFirst()`:
    
      ```java
      public void addFirst(T item) {
        if (item == null) {
            throw new NullPointerException();
        }
      
        head = (head - 1 + elements.length) % elements.length;
        elements[head] = item;
        size++;
      
        if (head == tail) {
            calculateSize(size * GROWTH_FACTOR);
        }
      }
      ```
  
      - Two pointer should move like circle. The different is that the `head` pointer moves backward (from index 0 to the end n then n-1, n-2 and so on), e.g. if `element.length = 4` and `head = 0 `then `3 % 4 = 3`, so item adds on index `3`. 
      - If the array is full, it should double its size.
    
      <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/addfirst.jpeg?raw=true" alt="deque" style="zoom:100%;" />
    
    - `addLast():`
    
      ```java
      public void addLast(T item) {
        if (item == null) {
            throw new NullPointerException();
        }
      
        elements[tail] = item;
        tail = (tail + 1) % elements.length;
        size++;
      
        if (head == tail) {
            calculateSize(size * GROWTH_FACTOR);
        }
      }
      ```
    
      - The `tail` pointer moves forward (from 0 to 1 to 2 and so on).
    
    - `removeFirst()`:
    
      ```java
      public T removeFirst() {
          if (isEmpty()) {
              return null;
          }
      
          T item = elements[head];
      
          elements[head] = null;
      
          head = (head + 1) % elements.length;
          size--;
      
          if (size > INITIAL_LENGTH && size < elements.length / 				 DOWN_USAGE_FACTOR) {
              calculateSize(elements.length / GROWTH_FACTOR);
          }
          return item;
      }
      ```
    
      - First set the head pointer's value as null then head should move circular forward (because the addFirst was backward). 
      - If after remove the value the array size is too big ((the number of elements / the array's length) < usage Factor), the array should reduce to save the memory.
    
      <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/removefirst.jpeg?raw=true" alt="deque" style="zoom:100%;" />
    
    - `removeLast()`:
    
      ```java
      public T removeLast() {
          if (isEmpty()) {
              return null;
          }
      
          tail = ((tail - 1) + elements.length) % elements.length;
      
          T item = elements[tail];
      
          elements[tail] = null;
          size--;
      
          if (size > INITIAL_LENGTH && size < elements.length / DOWN_USAGE_FACTOR) {
              calculateSize(elements.length / GROWTH_FACTOR);
          }
          return item;
      }
      ```
    
      - First move the tail pointer backward (the addLast was forward), because the value of last item stored at the previous index of the tail pointer. Then set the value as null.
    
    - `calculateSize()`: 
    
      ```java
      private void calculateSize(int newSize) {
          T[] resized = (T[]) new Object[newSize];
          /* V1 */
          for (int i = 0; i < size; i++) {
              int src = (head + i) % elements.length;
              int dest = i;
              resized[dest] = elements[src];
          }
      
          /* V2 */
          if (size + head < elements.length) {
              System.arraycopy(elements, head, resized, 0, size);
          } else {
              /* Copy left side items of the head pointer. */
              System.arraycopy(elements, head, resized, 0, elements.length - head);
              /* Copy right side items of the head pointer. */
              System.arraycopy(elements, 0, resized, elements.length - head, head);
          }
      
          elements = resized;
          head = 0;
          tail = size;
      }
      ```
    
      <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/changecap.jpeg?raw=true" alt="deque" style="zoom:100%;" />
    
      - If the array is full, it should double its size. If the usage factor is too low, it should reduce its size. There's two way to implementate this.
    
      1. Uses `for` loop to copy the array into the new array with new size. It can avoid to adds nulls. Similar to the `get()`, simply copy all items after `head`.
      2. Uses `System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`. There's two situations: 
         1. if `size + head < elements.length`: the number of items plus the index of the head is still less than the length of the array, it means there's nulls on the left side of the head. In this case it should only copy the right side of the head. 
         2. Otherwise, just copy the items on the left and right sides of the head pointer separately.
    
    - `get()`:
    
      ```java
      public T get(int index) {
          if (isEmpty() || index > size) {
              return null;
          }
      
          int theIndex = (head + index) % elements.length;
          return elements[theIndex];
      }
      ```
    
      - The input `index` is not the "real" index, because the head pointer is where the array starts, so the `head` is our index `0`. It means the real index is after the head which is `(head+inde)`.

## 2.5 Built-in List

- Lists:

  ```java
  import java.util.List;
  import java.util.ArrayList;
  
  public class Example {
      public static void main(String[] args) {
          List<Integer> L = new ArrayList<>();
          L.add(5);
          L.add(10);
          System.out.println(L);
      }
  }
  ```

- Sets:

  ```java
  import java.util.Set;
  import java.util.HashSet;
  
  Set<String> s = new HashSet<>();
  s.add("Tokyo");
  s.add("Lagos");
  System.out.println(S.contains("Tokyo")); // true
  ```

# 3. Testing

- **Ad Hoc Testing**

```java
/** Tests the Sort class. */
public class TestSort {
    /** Tests the sort method of the Sort class. */
    public static void testSort() {
        String[] input = {"i", "have", "an", "egg"};
        String[] expected = {"an", "egg", "have", "i"};
      
        Sort.sort(input);
      
        for (int i = 0; i < input.length; i += 1) {
            if (!input[i].equals(expected[i])) {
                System.out.println("Mismatch in position " + i + ", 
                                   expected: " + expected + ", but got: " +
                                   input[i] + ".");
                break;
            }
        }
    }

    public static void main(String[] args) {
        testSort();
    }
}
```

- **JUnit Testing**

  - Precede each method with `@org.junit.Test` (no semi-colon).
  - Change each test method to be **non**-static.
  - Remove our `main` method from the `TestSort` class.
  - Run the Code: Run -> Run...
  - `import org.junit.Test;` -> simply use `@Test`
  - `import static org.junit.Assert.*;` -> `assertEquals(<expected>, <actual>)`
  - default renderer: red/green arrows 
- jh61b renderer: white/blue boxes
  - See "Selection Sort"
  
  ```java
  public static void testSort() {
      String[] input = {"i", "have", "an", "egg"};
      String[] expected = {"an", "egg", "have", "i"};
      Sort.sort(input);
    	/* Use `org.junit` library */
      org.junit.Assert.assertArrayEquals(expected, input);
  }
  ```

- Selection Sort

  1. Find the smallest item.
  2. Move it to the front.
  3. Selection sort the remaining N-1 items (without touching the front item).

  ```java
  /* Sort Class */
  public class Sort {
      /** Sorts strings destructively. */
      public static void sort(String[] x) { 
         /* selection sort the rest (using recursion by helper methods) */
  			sort(x, 0);
      }
    
    	/** Sorts strings destructively starting from item start. */
      private static void sort(String[] x, int start) { 
         if (start == x.length) {
             return;
         }
         /* find the smallest item */
     		int smallestIndex = findSmallest(x, start);
         /* move it to the front */
         swap(x, start, smallestIndex);
         sort(x, start + 1);
      }
  
    	/** Swap item a with b */
    	public static void swap(String[] x, int a, int b) {
          String temp = x[a];
          x[a] = x[b];
          x[b] = temp;
  		}
    
      /** Returns the smallest string in x. */
      public static int findSmallest(String[] x, int start) {
          int smallestIndex = start;
          for (int i = start; i < x.length; i += 1) {
              int cmp = x[i].compareTo(x[smallestIndex]);
              if (cmp < 0) {
                  smallestIndex = i;
              }
          }
          return smallestIndex;
      }
  }
  ```

  ```java
  import org.junit.Test;
  import static org.junit.Assert.*;
  
  /* TestSort Class */
  public class TestSort {
      ...
      /** Test the Sort.findSmallest method. */
      @Test
      public void testFindSmallest() {
          String[] input = {"i", "have", "an", "egg"};
          int expected = 2;
  
          int actual = Sort.findSmallest(input, 0);
          /* org.junit.Assert.assertEquals(expected, actual); */  
        	assertEquals(expected, actual); 
  
          String[] input2 = {"there", "are", "many", "pigs"};
          int expected2 = 2;
  
          int actual2 = Sort.findSmallest(input2, 2);
          /* org.junit.Assert.assertEquals(expected2, actual2); */
        	assertEquals(expected2, actual2);
      }
    
      /** Test the Sort.swap method. */
    	@Test
      public void testSwap() {
          String[] input = {"i", "have", "an", "egg"};
          int a = 0;
          int b = 2;
          String[] expected = {"an", "have", "i", "egg"};
  
          Sort.swap(input, a, b);
          /* org.junit.Assert.assertArrayEquals(expected, input); */
        	assertArrayEquals(expected, input);
      }
  }
  ```

- `of` method: for example, to create an `IntList` containing the numbers 0, 1, 2, and 3, we could use the method as follows: 

  ```java
  IntList myList = IntList.of(0, 1, 2, 3);
  // Creates the IntList 0 -> 1 -> 2 -> 3 -> null
  ```

  - `myList.first` returns 0
  - `myList.rest` returns 1 -> 2 -> 3 -> null
  - `myList.rest.rest.rest` returns 3 -> null
  - `myList.rest.rest.rest.rest` returns null

- Style Checker: right Klic at the .java in IDEA - Checking Style

# 4. Inheritance 

## 4.1 Intro and Interfaces

- **Method Overloading:** Java allows multiple methods with same name, but different parameters. 

  ```java
  public static String longest(SLList<String> list)
  public static String longest(AList<String> list)
  ```

  - When you call `WordUtils.longest`, Java knows which one to run according to what kind of parameter you supply it. If you supply it with an AList, it will call the AList method. Same with an SLList.

- **Interface Inheritance:** is a specification of what a List is able to do (methods and parameters), not how to do. The subclass must have all methods of the interface. Use the keyword `interface`.

  - Step 1: 

  ```java
  public interface List61B<T> {
      public voif addLast(T x);
      public T getLast();
      public T get(int i);
      public int size();
      public T removeLast();
      public void insert(T x, int position);
      public void addFirst(T x);
      public T getFirst();
  }
  ```

  - Step 2: use the keyword `implements`

  ```java
  public class AList<T> implements List61B<T> {
      ...
      public void addLast(T x) {
          ...
      }
  }
  ```

  - The qualities of interfaces:
    - All methods must be public.
    - All variables must be public static final.
    - Cannot be instantiated
    - All methods are by default abstract unless specified to be `default`
    - Can implement more than one interface per class

- **Overriding and Overloading:** 

  - Override: a subclass has a method with the exact same signature as in the superclass

    ```java
    public interface Animal {
    	public void makeNoise();
    }
    
    /** Pig overrides makeNoise() */
    public class Pig implements Animal {
    	public void makeNoise() {
    		System.out.print("oink");
    	}
    }
    ```

  - Overload: a subclass has a method with the same name but different signatures as in the superclass

    ```java
    /** makeNoise is overloaded */
    public class Dog implements Animal {
    	public void makeNoise(Dog x) {
    		...
    	}
    }
    
    /** absis overloaded */
    public class Math {
      public int abs(int a)
      public double abs(double a)
    }
    ```

  - use `@Override` tag at the top for all methods that been overrided. 
  
- **Implementation Inheritance:** tells the subclasses how they should behave. Subclasses can inherit signatures and implementation. You must include the `default` keyword in the method signature.   

  ```java
  public interface List61B<T> {
      ...
      default public void print() {
          for (int i = 0; i < size(); i += 1) {
              System.out.print(get(i) + " ");
          }
          System.out.println();
      }
  }
  ```

  For an `SLList`, the `get` method needs to jump through the entirety of the list. during each call. It's much better to just override the `print` method.

  ```java
  @Override
  public void print() {
      for (Node p = sentinel.next; p != null; p = p.next) {
          System.out.print(p.item + " ");
      }
  }
  ```


- **Extends:** uses the `extends` keyword to inherit a class not interface, this defines "is-a" relationship. Subclasses inherit all **members** of the parent class. "Members" includes: all instance and static variables, all methods and all nested classes.

  - Note that **constructors** are not inherited, and **private** members cannot be directly accessed by subclasses.

    ```java
    public class RotatingSLList<Item> extends SLList<Item> {
      /** Rotates list to the right. */
      public void rotateRight() {
        Item x = removeLast();
        addFirst(x);
    	}
    }
    ```

  - If we want to **override** a method and call this method defined in the parent class, using the `super` keyword. e.g. `removeLast`

    ```java
    public class VengefulSLList<Item> extends SLList<Item> {
        SLList<Item> deletedItems;
    
        public VengefulSLList() {
            deletedItems = new SLList<Item>();
        }
    
        @Override
        public Item removeLast() {
            Item x = super.removeLast();	// Using super keyword
            deletedItems.addLast(x);
            return x;
        }
    
        /** Prints deleted items. */
        public void printLostItems() {
            deletedItems.print();
        }
    }
    ```

  - **Constructors Are Not Inherited**: Uses the `super` keyword to call parent's constructor.

    ```java
    public VengefulSLList() {
        super();
        deletedItems = new SLList<Item>();
    }
    ```

    - Adding `super()` has no difference from the constructor before (Line 4 to 6). And `super()` will implicit call to the default constructor, so it must call the constructor explict e.g. `super(x)`. 
  
- **Higher Order Functions:**

  
  - In old school Java (Java 7 and earlier), memory boxes (variables) could not contain pointers to functions. To get around this we can take advantage of interface inheritance.
  
  ```java
  /** Reprensent a function that takes in an integer and returns an integer */
  public interface IntUnaryFunction {
      int apply(int x);
  }
  ```
  
  ```java
  public class TenX implements IntUnaryFunction {
      public int apply(int x) {
          return 10 * x;
      }
  }
  ```
  
  ```java
  /** Demonstrates higher order functions in java */
  public class HofDemo {
      public static int do_twice(IntUnaryFunction f, int x) {
          return f.apply(f.apply(x));
      }
      
      public static void main(String[] args) {
          IntUnaryFunction tenX = new TenX();
          System.out.println(do_twice(tenX, 2))
      }
  }
  ```

## 4.2 Polymorphism

- **Polymorphism** refers to how objects can have many forms or types. In object-oriented programming, polymorphism relates to how an object can be regarded as an instance of its own class, an instance of its superclass, an instance of its superclass's superclass, and so on.
- We can create an **interface** that guarantees that any implementing class, like Dog, contains a comparison method, which we'll call `compareTo`.

  ```java
  public static OurComparable max(OurComparable[] items) {
      int maxDex = 0;
      for (int i = 0; i < items.length; i += 1) {
          int cmp = items[i].compareTo(items[maxDex]);
          if (cmp > 0) {
              maxDex = i;
          }
      }
      return items[maxDex];
  }
  ```
  
  ```java
  public interface OurComparable {
    
      /** 
      	* Return negative number if this < o
        * Return 0 if this equals o
     	  * Return positive number if this > o
     	  */
      public int compareTo(Object o);
  }
  ```
  
  ```java
  public class Dog implements OurComparable {
      private String name;
      private int size;
      
      public Dog(String n, int s) {
          name = n;
          size = s;
      }
      
      public void bark() {
          System.out.println(name + " says: bark");
      }
      
      /** the interface */ 
      public int compareTo(Object o) {
          Dog uddaDog = (Dog) o;
          return this.size - uddaDog.size;
          }
      }
  }
  ```
  
  - By declaring that it `implements OurComparable`, the Dog class makes a claim that it "is-an" OurComparable. As a result, the compiler checks that this claim is actually true, but sees that Dog **doesn't** implement `compareTo`. The solution is to use the built-in interface `Comparable<T>`.
  
    ```java
    public interface Comparable<T> {
        public int compareTo(T obj);  
    }
    ```
  
    ```java
    public class Dog implements Comparable<Dog> {
        /** Avoid cast an object */
        public int compareTo(Dog uddaDog) {
            return this.size - uddaDog.size;
        }
    }
    ```

- **Comparator**: use `java.util.Comparator` to define how two objects compare, e.g. by their name.

  ```java
  public interface Comparator<T> {
      int compare(T o1, T o2);
  }
  ```


## 4.3 Abstract Class

- The three most important Abstract data type (ADTs) come in the java.util library:

  - **List**: an ordered collection of items, e.g. Linked List, ArrayList

  - **Set**: an unordered collection of strictly unique items (no repeats), e.g. HashSet, TreeSet

  - **Map**: a collection of key/value pairs like dictionary in python. You access the value via the key, e.g. HashMap, TreeMap

- Abstract Classes:

  - Use the keyword `abstract`.
  - Subclass use the keyword `extends` and can only extend one abstract class.
  - Can do anything an interface can do and more.
  - Methods can be public or private
  - Can have any types of variables
  - Cannot be instantiated
  - Methods are by default concrete unless specified to be `abstract`
  - Can only implement one per class

  ```java
  public abstract class GraphicObject {    
    public int x, y;    
    public void moveTo(int newX, int newY) {...}    
    public abstract void draw(); 
  } 
  ```

## 4.4 Pakages

```java
package_name.classname.subclassname a = new package_name.classname.subclassname();

import package_name.classname.subclassname;
```

# 5. Java Syntax

## 5.1 Autoboxing & Auto-unboxing

- Autoboxing is the Java’s automatic conversion of between wrappers (Integer) to primitives (int).

- Automatic Conversions:

  ```java
  public class BasicArrayList {
      public static void main(String[] args) {
          ArrayList<Integer> L = new ArrayList<Integer>();
          L.add(5);   					// normally should be: L.add(new Integer(5))
          int first = L.get(0);  // normally should be: L.get(0).valueOf();
      }
  }
  ```

  - If Java code expects a wrapper type (e.g. `Integer`) and gets a primitive, it is auto boxed.

    ```java
    public static void blah(Integer x) {
      System.out.println(x);
    }
    
    int x = 20;
    blah(x);
    ```

  - Likewise, if the code expects a primitive (e.g. `int`) and gets a wrapper, it is unboxed.

    ```java
    public static void blahPrimitive(int x) {
      System.out.println(x);
    }
    
    Integer x = new Integer(20);
    blahPrimitive(x);
    ```

- There are a few things to keep in mind when it comes to autoboxing and unboxing:

  - Arrays are never autoboxes or auto-unboxed, e.g. if you have an array of integers `int[] x`, and try to put its address into a variable of type `Integer[]`, the compiler will **not** allow your program to compile.
  - Autoboxing and unboxing also has a measurable performance impact. That is, code that relies on autoboxing and unboxing will be slower than code that eschews such automatic conversions.
  - Additionally, wrapper types use much more memory than primitive types. On most modern comptuers, not only must your code hold a 64 bit reference to the object, but every object also requires 64 bits of overhead used to store things like the dynamic type of the object.

## 5.2 Immutability

- An immutable data type is a data type whose instances cannot change in any observable way after instantiation. The `final` keyword will help the compiler ensure immutability.

- Declaring a reference as **final** does not make the object that reference is pointing to immutable! For example, consider the following code snippet:

  ```java
  public final ArrayDeque<String>() deque = new ArrayDeque<String>();
  ```

  - The `deque` variable is final and can never be reassigned, but the array deque object its pointing to can change! ArrayDeques are always mutable!

## 5.3 Exception

- e.g. If the value at `items[i]` is null, then we are calling `null.equals(x)` -> NullPointerException. In Java, Exceptions are objects and we throw exceptions explicit using the following format:

  ```java
  throw new ExceptionObject(parameter1, ...);
    
    // e.g.
    throw new IllegalArgumentException("...");
  ```

## 5.4 Iteration

- Enhanced For Loop, its like `for … in` from Python.

  ``` java
  Set<String> s = new HashSet<>();
  s.add("Tokyo");
  s.add("Lagos");
  for (String city : s) {
      System.out.println(city);
  }
  ```

- Iterator: to run the code below, be sure that 

  1. the List interface has an `iterator()` method, since `friends` is a List, on which `iterator()` is called. 
  2. And the Iterator interface has `next/hasNext()` methods, since `seer` is an Iterator, on which `hasNext()` and `next()` are called.

  ``` java
  List<Integer> friends = new ArrayList<Integer>();
  Iterator<Integer> seer = friends.iterator();
  
  while (seer.hasNext()) {
      System.out.println(seer.next());
  }
  ```

  - To implement these requirements, the `List<T>` interface extends the `Iterable` interface, inheriting the abstract `iterator()` method. Then check that Iterators have `hasNext()` and `next()`.

    ```java
    // 1.
    public interface Iterable<T> {
        Iterator<T> iterator();
    }
    
    public interface List<T> extends Iterable<T>{
        ...
    }
    
    // 2.
    public interface Iterator<T> {
        boolean hasNext();
        T next();
    }
    ```


## 5.5 Packages and JAR files

- A package is a namespace that organises classes and interfaces.Package name starts with website address, backwards, e.g. com.microsoft.xxx.

- Creating a Package in IntelliJ: File → New Package → Choose package name → Right click package name → select New → Java Class → Name your class, and IntelliJ will automatically put it in the correct folder + add the “package com.microsoft.xxx” declaration for you.

- Any Java class without an explicit package name at the top of the file is automatically considered to be part of the “default” package.

- **JAR:** .jar file “zip” all the all .class files. JAR files are just like zip files.
  - Creating a JAR file in INtelliJ:
    1. Go to File → Project Structure → Artifacts → JAR → “From modules with dependencies”
    2. Click OK a couple of times
    3. Click Build → Build Artifacts (this will create a JAR file in a folder called “Artifacts”)
    4. Distribute this JAR file to other Java programmers, who can now import it into IntelliJ (or otherwise)
  - Build Systems: to avoid the need to import a bunch of libraries. Popular build systems include: Ant, Maven, Gradle.

## 5.6 Access Control

| Modifier  | Class | Package | Subclass | World |
| --------- | ----- | ------- | -------- | ----- |
| public    | Y     | Y       | Y        | Y     |
| protected | Y     | Y       | Y        | N     |
|           | Y     | Y       | N        | N     |
| private   | Y     | N       | N        | N     |

- **Package Private:** This is the default access given to Java members if there is no explicit modifier written. Package private entails that classes that belong in the same package can access, but not subclasses! 

```java
package universe;
public interface BlackHole {
    void add(Object x); // this method is public, not package-private!
}

package universe;
public class CreationUtils {
    public static BlackHole hirsute() {
         return new HasHair();
    }
}

package universe;
class HasHair implements BlackHole {
    Object[] items;
    public void add(Object o) { ... }
    public Object get(int k) { ... }
}

import static CreationUtils.hirsute;
class Client {
   void demoAccess() {
      BlackHole b = hirsute();
      b.add("horse");
      b.get(0);
      HasHair hb = (HasHair) b;
   }
}
```

- `b.get(0)`: This line errors because `b` is of static type `BlackHole`, but the `BlackHole` interface does not define a `get` method! Even though that `b` is dynamically a `HasHair`, and thus has the `get` method, the compiler bases its checks off the static type.
- `HasHair hb = (HasHair) b`: the `HasHair` class doesn’t have access modifier, so is not a public class - it's package-private. This means that `Client`, a class outside of the `universe` package, can't see that the `HasHair` class exists.
- `equals(Object obj):` To determine if two objects have the same value, use `equals()`, while `==` is used to check if two objects are the same object. Note: The default implementation of `equals()` is `==`, so you need to override `equals()` yourself, e.g. proj2.byog.Core.Game.java: `processKey()` - Gold Points - Check the position of the door.



# 6. Tree

## 6.1 Asymptotics 

- **Time complexity**: How much time does it take for your program to execute?

  - For N $\ge$ 100,000: $n$ – $n\log_2n$ – $n^2$ – $n^3$ – $2^n$ – $n!$

- **Space complexity**: How much memory does your program require? 

- Simplified Analysis Process

  ```java
  int N = A.length;
  for (int i = 0; i < N; i += 1)
     for (int j = i + 1; j < N; j += 1)
        if (A[i] == A[j])
           return true;
  return false;
  ```

  - Worst case number of `==` operations: $C=1+2+3+\dots+(N-3)+(N-2)+(N-1)=N(N-1)/2$. Which means the worst case order of growth of runtime is $\Theta(N^2)$.

- Order of Growth
  - Big-Theta Notation: $R(N)\in\Theta(f(N))$. “equals” to $f(N)$.
  - Big O Notation: $R(N)\in O(f(N))$. “Less than or equal” to $f(N)$.
  - Big Omega Notation: $R(N)\in\Omega(f(N))$. “More than or equal” to $f(N)$.









 























