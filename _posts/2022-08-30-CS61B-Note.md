---
title: CS61B Note
author:
  name: Terry
  link: https://github.com/tasogarenaki
date: 2022-08-30 20:00:00 +0200
categories: [Note, CS]
tags: [note, java, cs61b]
math: true
mermaid: true

---




# 1 Introduction

- Set the course code

  1. Create a repository from GitHub

  2. Create a folder `A` on local 

  3. ```consoleÂ 
     $ cd A
     $ git clone https://github.com/my_repository.git
     $ cd B (Folder inside A)
     $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git
     $ git pull skeleton master
     ```

  4. Move the `HelloWorld.java` and `HelloNumbers.java` that you previously created into the `lab1`directory.

  5. ```
     $ git add lab1/*
     $ git commit -m "completed first part of lab1"
     $ git push origin master
     ```

     <br>
- IntelliJ IDEA (Every Time!)

  1. Open - Choose the project file (not CS61B)
  2. File - Project Structure - Libraries - + - Java - CS61B/library-sp18/javalib - OK - OK
  3. File - New Projects Setup - Structure - Project - SDK: choose one - OK - open a file - Setup SDK

<br>

- Debugger
  - Breakpoints (right click for the breakpoint conditional)
  - Stepping over: step by step
  - Stepping into: get into the method
  - Stepping out: get out of the method 
  - Resum

<br>

- Some key syntactic features:

  - `public class`: all code lives inside of classes.

  - The code that is run is inside of a method called `main`, which is declared as `public static void main(String[] args)`.

    - `void`: It has no return type.
    - `main`: This is the name of the method.
    - `String[] args`: This is a parameter that is passed to the main method.

  - Use `{` and `}` to denote the beginning and the end of a section of code.
  - Statements must end with semi-colons `;`.
  - Comments with `/* */` or `//`.
  - Javadoc: `/** */` for methods or classes.
  - Compiler and Run Java program via Terminal:

    ```
      $ javac name.java
      $ java name
    ```

  - `static` type for all variables and expressions

    - Variables must be declared before it is used, and must have a specific type and the type can never change.
        - Let the programmer know exactly what sort of objekt is working with
        - No type erros

    ```java
      int x = 0;
      
      string x = "test";  // error
    ```

  - `System.out.print` will not print a newline (return), `System.out.println` will print a newline.

  - `@param` name a varialbe 

    ```java
    /**
    * @param variable name 
    * @param expected Expected double
    * 
    * or
    *
    * @param("name") String variable
    */
    ```


  - `static final` to declare any constans, e.g. the gravitational constant G

    ```java
    private static final double G = 6.67e-11;
    ```

  - `for-each` loop: to iterate through elements of arrays and collections

    ```java
    /* for (type var : array) { }; */
    int[] numArray = { 1, 2, 3, 4, 5, 6 };    
    
    for (int i : numArray) {      
      System.out.print(i);    
    }
    
    // -> 123456 
    
    /* is equivalent to: */
    int[] numArray = { 1, 2, 3, 4, 5, 6 };   
    
    for (int i = 0; i < numArray.length; i++) {      
      int j = numArray[i];	// j is i in first case   
      System.out.println(j);    
    }
    ```

  <br>

- Functions:

  - Functions must be declared as part of a class. A function that is part of a class is method, so all functions are methods.
    - To define a function use `public static` (e.g. Python `def`).
    - All parameters of a functions must be declared.

  ```java
    public class LargerDemo {
        /** Returns the larger of x and y. */
        public static int larger(int x, int y) {
            if (x > y) {
                return x;
            }
            return y;
        }
    
        public static void main(String[] args) {
            System.out.println(larger(8, 10));
        }
    }
  ```

  <br>

- Class

  - Examle:

    ```java
    /* Dog.java */
    public class Dog {		// non-static
        public int weightInPounds;		// instance variable 
        
        /* One integer constructor for dogs */
        public Dog(int w) {		// e.g. python def __init__
            weightInPounds = w;
        }
        
        public void makeNoise() {		// non-static method 
            if (weightInPounds < 10) {
                System.out.println("yip!");
            } else if (weightInPounds < 30) {
                System.out.println("bark");
            } else {
                System.out.println("wooof!");
            }
        }
    }
    
    /* DogLauncher.java */
    public class DogLauncher {		  // client of Dog class
        public static void main(String[] args) {
            Dog d = new Dog();			// Declaration a new variable of type Dog
            d.weightInPounds = 51;	// Instantiation
            d.makeNoise();				 // Invocation
        }
    }
    
    > javac Dog.java
    > javac DogLauncher.java
    > java DogLauncher
    wooof!
    ```

    - A class that uses another class is sometimes called a "client" of that class, i.e. `DogLauncher` is a client of `Dog`. 
    - Instance variables or non-static variables must be declared inside the class. 
    - The `makeNoise()` is a **non-static / instance** method, and do not have the `static` keyword. If the method is going to be invoked by an instance of the class, then it should be non-static. It means, if one method needs to use the instance variable, the method must be non-static.
      - To call the `makeNoise` method should using the `new` keyword to instantiate a `Dog`, then call `d.makeNoise()`.
    - The constructor with signature `public Dog(int w)` will be invoked anytime that we try to create a `Dog` using the `new` keyword and a single integer parameter. Similar to Python `__init__` method.
    
  - **Non-static** Methods are actions that can be taken only by a specific instance of a class. 

    ```java
    Math m = new Math();
    x = m.sqrt(100);
    ```

  - **Static** methods are actions that are taken by the class itself.

    ```java
    x = Math.sqrt(100);
    ```

  - Non-static:

    ```java
    public Dog maxDog(Dog d2) {	 // non-static method
        if (this.weightInPounds > d2.weightInPounds) {
            return this;	// use the keyword this to refer to the current object
        }
        return d2;
    }
    
    /* invoke */
    Dog d = new Dog(15);	
    Dog d2 = new Dog(100);
    d.maxDog(d2);
    ```

  - Static: 

    ```java
    public class Dog {
        public int weightInPounds;
        public static String binomen = "Canis familiaris";	// static variable
        ...
    }
    
    /* invoke */
    Dog.binomen
    ```

  <br>

- Arrays of objects

  - use `new` keyword to create the array
  - use `new` again for each object that needs to put in the array

  ```java
  /* example 1 */
  Dog[] dogs = new Dog[2];		// Creates an array of Dogs of size 2
  dogs[0] = new Dog(8);			  // dog 1 has value of 8 
  dogs[1] = new Dog(20);
  dogs[0].makeNoise();			  // dog 1 invoke the method 
  
  /* example 2 */
  int[] name = new int[5];
  name[0] = 1;
  name[1] = 2; 
  
  /* example 3*/
  int[] myList = {1, 2, 3};
  ```



# 2. Lists

## 2.1 SLList (Singly Linked List)

```java
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

```java
public class SLList {
    public IntNode first;
    
    public SLList(int x) {
        first = new IntNode(x, null);
    }
    
    /** Adds x to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
    
  /** Returns the first item in the list. */
    public int getFirst() {
        return first.item;
    }
    
    public static void main(String[] args) {
        /* Creates a list of one integer, namely 10 */
      	SLList L = new SLList(10);
        L.addFirst(10);
        int x = L.getFirst();	// outputs 10
    }
}
```

<br>

- Public vs. Private

  ```java
  /* change public to private */
  private IntNode first;
  ```

  - Private variables and methods can only be accessed by code inside the same `.java` file, e.g. in this case `SLList.java`. Other class can not invoke `first`. But can through `public` methods like `public void addFirst` to invoke or edit `first`.

<br>

- Nested Class 

  - Put a class inside of another class. Do not need two java files. 
  - If the nested class has no need to use any of the instance methods or variables of enclosing class, then can declare with `static`. Which means that methods inside of static class can not access any of the members of the enclosing class.
  - e.g. `IntNode` class is depends on `SLList` class, so can put in inside of `SLList`

  ```java
  public class SLList { 
      private class IntNode {
          public int item;
          public Node next;
  
          public IntNode(int i, IntNode n) {
              item = i;
              next = n;
          }
      }
    
      public IntNode first;
      public SLList(int x) {
          first = new IntNode(x, null);
      }
      
      /** Adds an item to the front of the list */
      public void addFirst(int x) {
          first = new IntNode(x, first);
      }
      
      public int getFirst() {
          return first.item;
      }
      
      public static void main(String[] args) {
          SLList L = new SLList(15);
          L.addFirst(10);
          int x = L.getFirst();
      }
  }
  ```

  - addLast and size
  
    ```java
    /** Adds an itemto the end of the list. */
    public void addLast(int x){
      IntNote p = first;
      
      /* Move p until it reaches the end of the list. */
      while (p.next != null){
        p = p.next;
      }
      
      p.next = new IntNote(x, null);
    }
    
    /** helper function 
    	* Returns the size of the list that starts at IntNode p. */
    private static int size(IntNode p) {
        if (p.next == null) {
            return 1;
        }
        return 1 + size(p.next);
    }
    
    public int size() {
        return size(first);
    }
    ```
  
    - use `private static` for helper function, to define this function can not invoked by outside.
    - `addLast()` is slow. Because we have to start at the front, and loop all the way to the back of our list before adding our element.
  
  <br>
  
  - **Sentinel Nodes:** 
  
    ```java
    /** Creates an empty SLList */
    public SLList(){
      sentinel = new IntNode(100, null);
      size = 0;
    }
    
    public SLList(int x){
      sentinel = new IntNode(100, null);
      sentinel.next = new IntNode(x, null);
      size = 1;
    } 
    
    public void addFirst(int x){
      sentinel.next = new IntNode(x, sentinel.next);
      size += 1;
    }
    
    public int getFirst(){
      return sentinel.next.item;
    }
    
    public void addLast(int x) {
        size += 1;
        IntNode p = sentinel;
      
        while (p.next != null) {
            p = p.next;
        }
    
        p.next = new IntNode(x, null);
    }
    ```
  
    - It's the first node and it's a dummy node, and not contains in the list.
    - It can be any number, because it will not be used. Its for `addLast`.
    - A `SLList` with a sentinel node has at least the following invariants:
      - The `sentinel` reference always points to a sentinel node.
      - The front item (if it exists), is always at `sentinel.next.item`.
      - The `size` variable is always the total number of items that have been added.
      - Inserting at the back of an SLList is much slower than the front.



## 2.2  DLList (Doubly Linked List)

- A node has a pointer to the next and the previous node. There's two way to implement it:

  1. Double Sentinel: There's a Sentinel Node at front and the end. `SentFront.next` is points to the first real Node, `prev` points to `null`. And `SentBack.next` points to `null`, `prev` points to the last real Node.

     <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/double_sentinel.png?raw=true" alt="double_sentinel" style="zoom:50%;" />

  2. Circular Sentinel: Only need one Sentinel Node, and this Sentinel Node `next` points to the first real Node, `prev` points to the last real Node. If there's no node, `next` and `prev` point to itself.

     <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/circular_sentinel.png?raw=true" alt="circular_sentinel" style="zoom:50%;" />

<br>

- Generic List: `<PLACEHOLDER>` after the class name. This allows the list to work not only for `int`, but also for i.e., `string` too.

  ```java
  /** Make a placeholder for this class, so you can declare the type later */
  public class DLList<HERE> {
      private IntNode sentinel;
      private int size;
  
      public class IntNode {
          public IntNode prev;
          public HERE item;
          public IntNode next;
          ...
      }
      ...
  }
  
  /** HERE is now Integer, so d1 is a int */
  DLList<Integer> d1 = new DLList<>(5);
  d1.insertFront(10);
  
  /** HERE is now String, so d2 is a String */
  DLList<String> d2 = new DLList<>("hello");
  d2.addLast("world");
  ```

  - int: Integer
  - double: Double
  - char: Character
  - boolean: Boolean
  - long: Long



## 2.3  AList (Array List)

- There are three valid notations for array creation
  - `y = new int[3];`
  - `x = new int[]{1, 2, 3, 4, 5};`
  - `int[] w = {9, 10, 11, 12, 13};`

<br>

- 2D Array

  ```java
  int[][] pascalsTriangle;					// declaration
  pasacalsTriangle = new int[4][];	// a 2D array contains four 1D array
  
  pascalsTriangle[0] = new int[]{1};// give a value at position 0
  
  int[][] matrix;
  matrix = new int[4][4];					 // four 2D array contain 5 int 1D array 
  
  /** all togher */
  int[][] pascalAgain = new int[][]{ {1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}};
  ```

- Alist:

  ```java
  public class AList<T> {
      private T[] items;
      private int size;
      
      /** Creates an empty list */
      public AList() {
        	/* Casts, if we want to use <T>: must new a Objetc 
             then transfer the arrys type */
          items = (T[]) new Object[100];
          size = 0;
      }
      
    	/** Resizes the underlying array to the target capacity */
      public void resize(int capacity) {
          T[] a = (T[]) new Object[capacity];
          System.arraycopy(items, 0, a, 0, size);
          items = a;
      }
      
      /** Inserts X into the back of the list */
      public void addLast(T x) {
          /* Resize items since its full */
          if (size == items.length) {
            /* faster */ 
            resize(size * 2); 
          }
          items[size] = x;
          size = size + 1;
      }
      
      /** Returns the item from the back of the list */
      public T getLast() {
          return items[size - 1];
      }
      
     	/** Deletes item from back of the list and returns deleted item */	
      public int removeLast() {
          int last = getLast();
        	/* not necessary */
          items[size-1] = null;	
          size = size - 1;
          return last;
      }
  }
  ```
  

## 2.4 Deque (Double ended queue)

<img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/deque.png?raw=true" alt="deque" style="zoom:50%;" />

- Specifically, any deque implementation must have exactly the following operations:
  - `public void addFirst(T item)`: Adds an item of type `T` to the front of the deque.
  - `public void addLast(T item)`: Adds an item of type `T` to the back of the deque.
  - `public boolean isEmpty()`: Returns true if deque is empty, false otherwise.
  - `public int size()`: Returns the number of items in the deque.
  - `public void printDeque()`: Prints the items in the deque from first to last, separated by a space.
  - `public T removeFirst()`: Removes and returns the item at the front of the deque. If no such item exists, returns null.
  - `public T removeLast()`: Removes and returns the item at the back of the deque. If no such item exists, returns null.
  - `public T get(int index)`: Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth. If no such item exists, returns null. Must not alter the deque!
  
- **Linked List Deque:**
  
  ```java
  /* Empty Linked List -> sentinel is a node with value null. */
  public LinkedListDeque() {
      sentinel = new Node<T>();
      sentinel.next = sentinel;
      sentinel.prev = sentinel;
      size = 0;
  }
  
  /* Adds an item to the front / back of the deque. */
  public void addFirst(T item) {
    Node<T> firstNode = new Node<T>(item);
    /* save the next node of sentinel in `next`, which should be pos 1. */
    Node<T> next = sentinel.next;
    /* copy `next`. */
    firstNode.next = next;
    /* points firstNode is the prev node of `next` */
    next.prev = firstNode;
    /* relocated the sentinel node */
    sentinel.next = firstNode;
    firstNode.prev = sentinel;
  
    size += 1;
  }
  
  public void addLast(T item) {
      Node<T> lastNode = new Node<T>(item);
      /* the prev node of the sentinel node points to the last node. */
      Node<T> prev = sentinel.prev;
  
      lastNode.prev = prev;
      prev.next = lastNode;
      sentinel.prev = lastNode;
      lastNode.next = sentinel;
  
      size += 1;
  }
  
  /* Prints the items in the deque from first to last. */
  public void printDeque() {
      for (Node<T> ptr = sentinel.next; ptr != sentinel; ptr = ptr.next) {
          System.out.print(ptr.item + " ");
      }
  }
  
  /* Removes and returns the item at the fonrt / back of the deque. */
  public T removeFirst() {
      return remove(sentinel.next);
  }
  
  public T removeLast() {
      return remove(sentinel.prev);
  }
  
  /* The helper function, see the grafic above */
  private T remove(Node<T> node) {
      if (size == 0) {
          return null;
      }
  
      Node<T> tempNext = node.next;
      Node<T> tempPrev = node.prev;
  
      tempPrev.next = tempNext;
      tempNext.prev = tempPrev;
      size--;
  
      return node.item;
  }
  ```
  
  - **Array Deque:** 
  
    - uses a circular array with two pointers head and tail. They both start at the same position, then the head pointer starts from back to front and the tail pointer from front to the end. If they meet again (head equals tail) it means the array is full.
  
    - Null is not allowed to add into the ArrayDeque.
    
    - `addFirst()`:
    
      ```java
      public void addFirst(T item) {
        if (item == null) {
            throw new NullPointerException();
        }
      
        head = (head - 1 + elements.length) % elements.length;
        elements[head] = item;
        size++;
      
        if (head == tail) {
            calculateSize(size * GROWTH_FACTOR);
        }
      }
      ```
  
      - Two pointer should move like circle. The different is that the `head` pointer moves backward (from index 0 to the end n then n-1, n-2 and so on), e.g. if `element.length = 4` and `head = 0 `then `3 % 4 = 3`, so item adds on index `3`. 
      - If the array is full, it should double its size.
    
      <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/addfirst.jpeg?raw=true" alt="deque" style="zoom:100%;" />
    
    - `addLast():`
    
      ```java
      public void addLast(T item) {
        if (item == null) {
            throw new NullPointerException();
        }
      
        elements[tail] = item;
        tail = (tail + 1) % elements.length;
        size++;
      
        if (head == tail) {
            calculateSize(size * GROWTH_FACTOR);
        }
      }
      ```
    
      - The `tail` pointer moves forward (from 0 to 1 to 2 and so on).
    
    - `removeFirst()`:
    
      ```java
      public T removeFirst() {
          if (isEmpty()) {
              return null;
          }
      
          T item = elements[head];
      
          elements[head] = null;
      
          head = (head + 1) % elements.length;
          size--;
      
          if (size > INITIAL_LENGTH && size < elements.length / 				 DOWN_USAGE_FACTOR) {
              calculateSize(elements.length / GROWTH_FACTOR);
          }
          return item;
      }
      ```
    
      - First set the head pointer's value as null then head should move circular forward (because the addFirst was backward). 
      - If after remove the value the array size is too big ((the number of elements / the array's length) < usage Factor), the array should reduce to save the memory.
    
      <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/removefirst.jpeg?raw=true" alt="deque" style="zoom:100%;" />
    
    - `removeLast()`:
    
      ```java
      public T removeLast() {
          if (isEmpty()) {
              return null;
          }
      
          tail = ((tail - 1) + elements.length) % elements.length;
      
          T item = elements[tail];
      
          elements[tail] = null;
          size--;
      
          if (size > INITIAL_LENGTH && size < elements.length / DOWN_USAGE_FACTOR) {
              calculateSize(elements.length / GROWTH_FACTOR);
          }
          return item;
      }
      ```
    
      - First move the tail pointer backward (the addLast was forward), because the value of last item stored at the previous index of the tail pointer. Then set the value as null.
    
    - `calculateSize()`: 
    
      ```java
      private void calculateSize(int newSize) {
          T[] resized = (T[]) new Object[newSize];
          /* V1 */
          for (int i = 0; i < size; i++) {
              int src = (head + i) % elements.length;
              int dest = i;
              resized[dest] = elements[src];
          }
      
          /* V2 */
          if (size + head < elements.length) {
              System.arraycopy(elements, head, resized, 0, size);
          } else {
              /* Copy left side items of the head pointer. */
              System.arraycopy(elements, head, resized, 0, elements.length - head);
              /* Copy right side items of the head pointer. */
              System.arraycopy(elements, 0, resized, elements.length - head, head);
          }
      
          elements = resized;
          head = 0;
          tail = size;
      }
      ```
    
      <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/changecap.jpeg?raw=true" alt="deque" style="zoom:100%;" />
    
      - If the array is full, it should double its size. If the usage factor is too low, it should reduce its size. There's two way to implementate this.
    
      1. Uses `for` loop to copy the array into the new array with new size. It can avoid to adds nulls. Similar to the `get()`, simply copy all items after `head`.
      2. Uses `System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`. There's two situations: 
         1. if `size + head < elements.length`: the number of items plus the index of the head is still less than the length of the array, it means there's nulls on the left side of the head. In this case it should only copy the right side of the head. 
         2. Otherwise, just copy the items on the left and right sides of the head pointer separately.
    
    - `get()`:
    
      ```java
      public T get(int index) {
          if (isEmpty() || index > size) {
              return null;
          }
      
          int theIndex = (head + index) % elements.length;
          return elements[theIndex];
      }
      ```
    
      - The input `index` is not the "real" index, because the head pointer is where the array starts, so the `head` is our index `0`. It means the real index is after the head which is `(head+inde)`.

# 3. Testing

- **Ad Hoc Testing**

```java
/** Tests the Sort class. */
public class TestSort {
    /** Tests the sort method of the Sort class. */
    public static void testSort() {
        String[] input = {"i", "have", "an", "egg"};
        String[] expected = {"an", "egg", "have", "i"};
      
        Sort.sort(input);
      
        for (int i = 0; i < input.length; i += 1) {
            if (!input[i].equals(expected[i])) {
                System.out.println("Mismatch in position " + i + ", 
                                   expected: " + expected + ", but got: " +
                                   input[i] + ".");
                break;
            }
        }
    }

    public static void main(String[] args) {
        testSort();
    }
}
```

- **JUnit Testing**

  - Precede each method with `@org.junit.Test` (no semi-colon).
  - Change each test method to be **non**-static.
  - Remove our `main` method from the `TestSort` class.
  - Run the Code: Run -> Run...
  - `import org.junit.Test;` -> simply use `@Test`
  - `import static org.junit.Assert.*;` -> `assertEquals(<expected>, <actual>)`
  - default renderer: red/green arrows 
- jh61b renderer: white/blue boxes
  - See "Selection Sort"
  
  ```java
  public static void testSort() {
      String[] input = {"i", "have", "an", "egg"};
      String[] expected = {"an", "egg", "have", "i"};
      Sort.sort(input);
    	/* Use `org.junit` library */
      org.junit.Assert.assertArrayEquals(expected, input);
  }
  ```

- Selection Sort

  1. Find the smallest item.
  2. Move it to the front.
  3. Selection sort the remaining N-1 items (without touching the front item).

  ```java
  /* Sort Class */
  public class Sort {
      /** Sorts strings destructively. */
      public static void sort(String[] x) { 
         /* selection sort the rest (using recursion by helper methods) */
  			sort(x, 0);
      }
    
    	/** Sorts strings destructively starting from item start. */
      private static void sort(String[] x, int start) { 
         if (start == x.length) {
             return;
         }
         /* find the smallest item */
     		int smallestIndex = findSmallest(x, start);
         /* move it to the front */
         swap(x, start, smallestIndex);
         sort(x, start + 1);
      }
  
    	/** Swap item a with b */
    	public static void swap(String[] x, int a, int b) {
          String temp = x[a];
          x[a] = x[b];
          x[b] = temp;
  		}
    
      /** Returns the smallest string in x. */
      public static int findSmallest(String[] x, int start) {
          int smallestIndex = start;
          for (int i = start; i < x.length; i += 1) {
              int cmp = x[i].compareTo(x[smallestIndex]);
              if (cmp < 0) {
                  smallestIndex = i;
              }
          }
          return smallestIndex;
      }
  }
  ```

  ```java
  import org.junit.Test;
  import static org.junit.Assert.*;
  
  /* TestSort Class */
  public class TestSort {
      ...
      /** Test the Sort.findSmallest method. */
      @Test
      public void testFindSmallest() {
          String[] input = {"i", "have", "an", "egg"};
          int expected = 2;
  
          int actual = Sort.findSmallest(input, 0);
          /* org.junit.Assert.assertEquals(expected, actual); */  
        	assertEquals(expected, actual); 
  
          String[] input2 = {"there", "are", "many", "pigs"};
          int expected2 = 2;
  
          int actual2 = Sort.findSmallest(input2, 2);
          /* org.junit.Assert.assertEquals(expected2, actual2); */
        	assertEquals(expected2, actual2);
      }
    
      /** Test the Sort.swap method. */
    	@Test
      public void testSwap() {
          String[] input = {"i", "have", "an", "egg"};
          int a = 0;
          int b = 2;
          String[] expected = {"an", "have", "i", "egg"};
  
          Sort.swap(input, a, b);
          /* org.junit.Assert.assertArrayEquals(expected, input); */
        	assertArrayEquals(expected, input);
      }
  }
  ```

- `of` method: for example, to create an `IntList` containing the numbers 0, 1, 2, and 3, we could use the method as follows: 

  ```java
  IntList myList = IntList.of(0, 1, 2, 3);
  // Creates the IntList 0 -> 1 -> 2 -> 3 -> null
  ```

  - `myList.first` returns 0
  - `myList.rest` returns 1 -> 2 -> 3 -> null
  - `myList.rest.rest.rest` returns 3 -> null
  - `myList.rest.rest.rest.rest` returns null

- Style Checker: right Klic at the .java in IDEA - Checking Style

# 4. Inheritance 

## 4.1 Intro and Interfaces

- **Method Overloading:** Java allows multiple methods with same name, but different parameters. 

  ```java
  public static String longest(SLList<String> list)
  public static String longest(AList<String> list)
  ```

  - When you call `WordUtils.longest`, Java knows which one to run according to what kind of parameter you supply it. If you supply it with an AList, it will call the AList method. Same with an SLList.

- **Interface Inheritance:** is a specification of what a List is able to do (methods and parameters), not how to do. The subclass must have all methods of the interface. Use the keyword `interface`.

  - Step 1: 

  ```java
  public interface List61B<T> {
      public voif addLast(T x);
      public T getLast();
      public T get(int i);
      public int size();
      public T removeLast();
      public void insert(T x, int position);
      public void addFirst(T x);
      public T getFirst();
  }
  ```

  - Step 2: use the keyword `implements`

  ```java
  public class AList<T> implements List61B<T> {
      ...
      public void addLast(T x) {
          ...
      }
  }
  ```

- **Overriding and Overloading:** 

  - Override: a subclass has a method with the exact same signature as in the superclass

    ```java
    public interface Animal {
    	public void makeNoise();
    }
    
    /** Pig overrides makeNoise() */
    public class Pig implements Animal {
    	public void makeNoise() {
    		System.out.print("oink");
    	}
    }
    ```

  - Overload: a subclass has a method with the same name but different signatures as in the superclass

    ```java
    /** makeNoise is overloaded */
    public class Dog implements Animal {
    	public void makeNoise(Dog x) {
    		...
    	}
    }
    
    /** absis overloaded */
    public class Math {
      public int abs(int a)
      public double abs(double a)
    }
    ```

  - use `@Override` tag at the top for all methods that been overrided. 
  
- **Implementation Inheritance:** tells the subclasses how they should behave. Subclasses can inherit signatures and implementation. You must include the `default` keyword in the method signature.   

  ```java
  public interface List61B<T> {
      ...
      default public void print() {
          for (int i = 0; i < size(); i += 1) {
              System.out.print(get(i) + " ");
          }
          System.out.println();
      }
  }
  ```

  For an `SLList`, the `get` method needs to jump through the entirety of the list. during each call. It's much better to just override the `print` method.

  ```java
  @Override
  public void print() {
      for (Node p = sentinel.next; p != null; p = p.next) {
          System.out.print(p.item + " ");
      }
  }
  ```


- **Extends:** uses the `extends` keyword to inherit a class not interface. Subclasses inherit all **members** of the parent class. "Members" includes: all instance and static variables, all methods and all nested classes.

  - Note that **constructors** are not inherited, and **private** members cannot be directly accessed by subclasses.

    ```java
    public class RotatingSLList<Item> extends SLList<Item> {
      /** Rotates list to the right. */
      public void rotateRight() {
        Item x = removeLast();
        addFirst(x);
    	}
    }
    ```

  - If we want to **override** a method and call this method defined in the parent class, using the `super` keyword. e.g. `removeLast`

    ```java
    public class VengefulSLList<Item> extends SLList<Item> {
        SLList<Item> deletedItems;
    
        public VengefulSLList() {
            deletedItems = new SLList<Item>();
        }
    
        @Override
        public Item removeLast() {
            Item x = super.removeLast();	// Using super keyword
            deletedItems.addLast(x);
            return x;
        }
    
        /** Prints deleted items. */
        public void printLostItems() {
            deletedItems.print();
        }
    }
    ```

  - **Constructors Are Not Inherited**: Uses the `super` keyword to call parent's constructor.

    ```java
    public VengefulSLList() {
        super();
        deletedItems = new SLList<Item>();
    }
    ```

    - Adding `super()` has no difference from the constructor before (Line 4 to 6).























