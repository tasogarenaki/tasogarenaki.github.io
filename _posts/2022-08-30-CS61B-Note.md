---
title: CS61B Note
author:
  name: Terry
  link: https://github.com/tasogarenaki
date: 2022-08-30 20:00:00 +0200
categories: [Note, CS]
tags: [note, java, cs61b]
math: true
mermaid: true

---




# 1 Introduction

- Set the course code

  1. Create a repository from GitHub

  2. Create a folder `A` on local 

  3. ```consoleÂ 
     $ cd A
     $ git clone https://github.com/my_repository.git
     $ cd B (Folder inside A)
     $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git
     $ git pull skeleton master
     ```

  4. Move the `HelloWorld.java` and `HelloNumbers.java` that you previously created into the `lab1`directory.

  5. ```
     $ git add lab1/*
     $ git commit -m "completed first part of lab1"
     $ git push origin master
     ```

     <br>
- IntelliJ IDEA (Every Time!)

  1. Open - Choose the project file (not CS61B)
  2. File - Project Structure - Libraries - + - Java - CS61B/library-sp18/javalib - OK - OK
  3. File - New Projects Setup - Structure - Project - SDK: choose one - OK - open a file - Setup SDK

<br>

- Debugger
  - Breakpoints (right click for the breakpoint conditional)
  - Stepping over: step by step
  - Stepping into: get into the method
  - Stepping out: get out of the method 
  - Resum

<br>

- Some key syntactic features:

  - `public class`: all code lives inside of classes.

  - The code that is run is inside of a method called `main`, which is declared as `public static void main(String[] args)`.

    - `void`: It has no return type.
    - `main`: This is the name of the method.
    - `String[] args`: This is a parameter that is passed to the main method.

  - Use `{` and `}` to denote the beginning and the end of a section of code.
  - Statements must end with semi-colons `;`.
  - Comments with `/* */` or `//`.
  - Javadoc: `/** */` for methods or classes.
  - Compiler and Run Java program via Terminal:

    ```
      $ javac name.java
      $ java name
    ```

  - `static` type for all variables and expressions

    - Variables must be declared before it is used, and must have a specific type and the type can never change.
        - Let the programmer know exactly what sort of objekt is working with
        - No type erros

    ```java
      int x = 0;
      
      string x = "test";  // error
    ```

  - `System.out.print` will not print a newline (return), `System.out.println` will print a newline.

  - `@param` name a varialbe 

    ```java
    /**
    * @param variable name 
    * @param expected Expected double
    * 
    * or
    *
    * @param("name") String variable
    */
    ```


  - `static final` to declare any constans, e.g. the gravitational constant G

    ```java
    private static final double G = 6.67e-11;
    ```

  - `for-each` loop: to iterate through elements of arrays and collections

    ```java
    /* for (type var : array) { }; */
    int[] numArray = { 1, 2, 3, 4, 5, 6 };    
    
    for (int i : numArray) {      
      System.out.print(i);    
    }
    
    // -> 123456 
    
    /* is equivalent to: */
    int[] numArray = { 1, 2, 3, 4, 5, 6 };   
    
    for (int i=0; i < numArray.length; i++) {      
      int j = numArray[i];	// j is i in first case   
      System.out.println(j);    
    }
    ```

  <br>

- Functions:

  - Functions must be declared as part of a class. A function that is part of a class is method, so all functions are methods.
    - To define a function use `public static` (e.g. Python `def`).
    - All parameters of a functions must be declared.

  ```java
    public class LargerDemo {
        /** Returns the larger of x and y. */
        public static int larger(int x, int y) {
            if (x > y) {
                return x;
            }
            return y;
        }
    
        public static void main(String[] args) {
            System.out.println(larger(8, 10));
        }
    }
  ```

  <br>

- Class

  - Examle:

    ```java
    /* Dog.java */
    public class Dog {		// non-static
        public int weightInPounds;		// instance variable 
        
        /* One integer constructor for dogs */
        public Dog(int w) {		// e.g. python def __init__
            weightInPounds = w;
        }
        
        public void makeNoise() {		// non-static method 
            if (weightInPounds < 10) {
                System.out.println("yip!");
            } else if (weightInPounds < 30) {
                System.out.println("bark");
            } else {
                System.out.println("wooof!");
            }
        }
    }
    
    /* DogLauncher.java */
    public class DogLauncher {		  // client of Dog class
        public static void main(String[] args) {
            Dog d = new Dog();			// Declaration a new variable of type Dog
            d.weightInPounds = 51;	// Instantiation
            d.makeNoise();				 // Invocation
        }
    }
    
    > javac Dog.java
    > javac DogLauncher.java
    > java DogLauncher
    wooof!
    ```

    - A class that uses another class is sometimes called a "client" of that class, i.e. `DogLauncher` is a client of `Dog`. 
    - Instance variables or non-static variables must be declared inside the class. 
    - The `makeNoise()` is a **non-static / instance** method, and do not have the `static` keyword. If the method is going to be invoked by an instance of the class, then it should be non-static. It means, if one method needs to use the instance variable, the method must be non-static.
      - To call the `makeNoise` method should using the `new` keyword to instantiate a `Dog`, then call `d.makeNoise()`.
    - The constructor with signature `public Dog(int w)` will be invoked anytime that we try to create a `Dog` using the `new` keyword and a single integer parameter. Similar to Python `__init__` method.
    
  - **Non-static** Methods are actions that can be taken only by a specific instance of a class. 

    ```java
    Math m = new Math();
    x = m.sqrt(100);
    ```

  - **Static** methods are actions that are taken by the class itself.

    ```java
    x = Math.sqrt(100);
    ```

  - Non-static:

    ```java
    public Dog maxDog(Dog d2) {	 // non-static method
        if (this.weightInPounds > d2.weightInPounds) {
            return this;	// use the keyword this to refer to the current object
        }
        return d2;
    }
    
    /* invoke */
    Dog d = new Dog(15);	
    Dog d2 = new Dog(100);
    d.maxDog(d2);
    ```

  - Static: 

    ```java
    public class Dog {
        public int weightInPounds;
        public static String binomen = "Canis familiaris";	// static variable
        ...
    }
    
    /* invoke */
    Dog.binomen
    ```

  <br>

- Arrays of objects

  - use `new` keyword to create the array
  - use `new` again for each object that needs to put in the array

  ```java
  /* example 1 */
  Dog[] dogs = new Dog[2];		// Creates an array of Dogs of size 2
  dogs[0] = new Dog(8);			  // dog 1 has value of 8 
  dogs[1] = new Dog(20);
  dogs[0].makeNoise();			  // dog 1 invoke the method 
  
  /* example 2 */
  int[] name = new int[5];
  name[0] = 1;
  name[1] = 2; 
  ```



# 2. Lists

## 2.1 SLList (Singly Linked List)

```java
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

```java
public class SLList {
    public IntNode first;
    
    public SLList(int x) {
        first = new IntNode(x, null);
    }
    
    /** Adds x to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
    
  /** Returns the first item in the list. */
    public int getFirst() {
        return first.item;
    }
    
    public static void main(String[] args) {
        /* Creates a list of one integer, namely 10 */
      	SLList L = new SLList(10);
        L.addFirst(10);
        int x = L.getFirst();	// outputs 10
    }
}
```

<br>

- Public vs. Private

  ```java
  /* change public to private */
  private IntNode first;
  ```

  - Private variables and methods can only be accessed by code inside the same `.java` file, e.g. in this case `SLList.java`. Other class can not invoke `first`. But can through `public` methods like `public void addFirst` to invoke or edit `first`.

<br>

- Nested Class 

  - Put a class inside of another class. Do not need two java files. 
  - If the nested class has no need to use any of the instance methods or variables of enclosing class, then can declare with `static`. Which means that methods inside of static class can not access any of the members of the enclosing class.
  - e.g. `IntNode` class is depends on `SLList` class, so can put in inside of `SLList`

  ```java
  public class SLList { 
      private class IntNode {
          public int item;
          public Node next;
  
          public IntNode(int i, IntNode n) {
              item = i;
              next = n;
          }
      }
    
      public IntNode first;
      public SLList(int x) {
          first = new IntNode(x, null);
      }
      
      /** Adds an item to the front of the list */
      public void addFirst(int x) {
          first = new IntNode(x, first);
      }
      
      public int getFirst() {
          return first.item;
      }
      
      public static void main(String[] args) {
          SLList L = new SLList(15);
          L.addFirst(10);
          int x = L.getFirst();
      }
  }
  ```

  - addLast and size
  
    ```java
    /** Adds an itemto the end of the list. */
    public void addLast(int x){
      IntNote p = first;
      
      /* Move p until it reaches the end of the list. */
      while (p.next != null){
        p = p.next;
      }
      
      p.next = new IntNote(x, null);
    }
    
    /** helper function 
    	* Returns the size of the list that starts at IntNode p. */
    private static int size(IntNode p) {
        if (p.next == null) {
            return 1;
        }
        return 1 + size(p.next);
    }
    
    public int size() {
        return size(first);
    }
    ```
  
    - use `private static` for helper function, to define this function can not invoked by outside.
    - `addLast()` is slow. Because we have to start at the front, and loop all the way to the back of our list before adding our element.
  
  <br>
  
  - **Sentinel Nodes:** 
  
    ```java
    /** Creates an empty SLList */
    public SLList(){
      sentinel = new IntNode(100, null);
      size = 0;
    }
    
    public SLList(int x){
      sentinel = new IntNode(100, null);
      sentinel.next = new IntNode(x, null);
      size = 1;
    } 
    
    public void addFirst(int x){
      sentinel.next = new IntNode(x, sentinel.next);
      size += 1;
    }
    
    public int getFirst(){
      return sentinel.next.item;
    }
    
    public void addLast(int x) {
        size += 1;
        IntNode p = sentinel;
      
        while (p.next != null) {
            p = p.next;
        }
    
        p.next = new IntNode(x, null);
    }
    ```
  
    - It's the first node and it's a dummy node, and not contains in the list.
    - It can be any number, because it will not be used. Its for `addLast`.
    - A `SLList` with a sentinel node has at least the following invariants:
      - The `sentinel` reference always points to a sentinel node.
      - The front item (if it exists), is always at `sentinel.next.item`.
      - The `size` variable is always the total number of items that have been added.
      - Inserting at the back of an SLList is much slower than the front.



## 2.2  DLList (Doubly Linked List)

- A node has a pointer to the next and the previous node. 4There's two way to implement it:

  1. Double Sentinel: There's a Sentinel Node at front and the end. `SentFront.next` is points to the first real Node, `prev` points to `null`. And `SentBack.next` points to `null`, `prev` points to the last real Node.

     <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/double_sentinel.png?raw=true" alt="double_sentinel" style="zoom:50%;" />

  2. Circular Sentinel: Only need one Sentinel Node, and this Sentinel Node `next` points to the first real Node, `prev` points to the last real Node. If there's no node, `next` and `prev` point to itself.

     <img src="https://github.com/tasogarenaki/tasogarenaki.github.io/blob/main/pics/cs61b/circular_sentinel.png?raw=true" alt="circular_sentinel" style="zoom:50%;" />

<br>

- Generic List: `<PLACEHOLDER>` after the class name. This allows the list to work not only for `int`, but also for i.e., `string` too.

  ```java
  /** Make a placeholder for this class, so you can declare the type later */
  public class DLList<HERE> {
      private IntNode sentinel;
      private int size;
  
      public class IntNode {
          public IntNode prev;
          public HERE item;
          public IntNode next;
          ...
      }
      ...
  }
  
  /** HERE is now Integer, so d1 is a int */
  DLList<Integer> d1 = new DLList<>(5);
  d1.insertFront(10);
  
  /** HERE is now String, so d2 is a String */
  DLList<String> d2 = new DLList<>("hello");
  d2.addLast("world");
  ```

  - int: Integer
  - double: Double
  - char: Character
  - boolean: Boolean
  - long: Long



## 2.3  AList (Array List)

- There are three valid notations for array creation
  - `y = new int[3];`
  - `x = new int[]{1, 2, 3, 4, 5};`
  - `int[] w = {9, 10, 11, 12, 13};`

<br>

- 2D Array

  ```java
  int[][] pascalsTriangle;					// declaration
  pasacalsTriangle = new int[4][];	// a 2D array contains four 1D array
  
  pascalsTriangle[0] = new int[]{1};// give a value at position 0
  
  int[][] matrix;
  matrix = new int[4][4];					 // four 2D array contain 5 int 1D array 
  
  /** all togher */
  int[][] pascalAgain = new int[][]{ {1}, {1, 1}, {1, 2, 1}, {1, 3, 3, 1}};
  ```

- Alist:

  ```java
  public class AList<T> {
      private T[] items;
      private int size;
      
      /** Creates an empty list */
      public AList() {
        	/* Casts, if we want to use <T>: must new a Objetc 
             then transfer the arrys type */
          items = (T[]) new Object[100];
          size = 0;
      }
      
    	/** Resizes the underlying array to the target capacity */
      public void resize(int capacity) {
          T[] a = (T[]) new Object[capacity];
          System.arraycopy(items, 0, a, 0, size);
          items = a;
      }
      
      /** Inserts X into the back of the list */
      public void addLast(T x) {
          /* Resize items since its full */
          if (size == items.length) {
            // faster 
            resize(size * 2); 
          }
          items[size] = x;
          size = size + 1;
      }
      
      /** Returns the item from the back of the list */
      public T getLast() {
          return items[size - 1];
      }
      
     	/** Deletes item from back of the list and returns deleted item */	
      public int removeLast() {
          int last = getLast();
        	/* not necessary */
          items[size-1] = null;	
          size = size - 1;
          return last;
      }
  }
  ```
  



# 3. Testing

- **Ad Hoc Testing**

```java
/** Tests the Sort class. */
public class TestSort {
    /** Tests the sort method of the Sort class. */
    public static void testSort() {
        String[] input = {"i", "have", "an", "egg"};
        String[] expected = {"an", "egg", "have", "i"};
      
        Sort.sort(input);
      
        for (int i = 0; i < input.length; i += 1) {
            if (!input[i].equals(expected[i])) {
                System.out.println("Mismatch in position " + i + ", 
                                   expected: " + expected + ", but got: " +
                                   input[i] + ".");
                break;
            }
        }
    }

    public static void main(String[] args) {
        testSort();
    }
}
```



- **JUnit Testing**

  - Precede each method with `@org.junit.Test` (no semi-colon).
  - Change each test method to be **non**-static.
  - Remove our `main` method from the `TestSort` class.
  - Run the Code: Run -> Run
  - `import org.junit.Test;` -> simply use `@Test`
  - `import static org.junit.Assert.*;` -> `assertEquals(expected2, actual2)`
  - See "Selection Sort"

  ```java
  public static void testSort() {
      String[] input = {"i", "have", "an", "egg"};
      String[] expected = {"an", "egg", "have", "i"};
      Sort.sort(input);
    	/** Use `org.junit` library */
      org.junit.Assert.assertArrayEquals(expected, input);
  }
  ```

  

- Selection Sort

  1. Find the smallest item.
  2. Move it to the front.
  3. Selection sort the remaining N-1 items (without touching the front item).

  ```java
  /* Sort Class */
  public class Sort {
      /** Sorts strings destructively. */
      public static void sort(String[] x) { 
         // selection sort the rest (using recursion by helper methods) 
  			sort(x, 0);
      }
    
    	/** Sorts strings destructively starting from item start. */
      private static void sort(String[] x, int start) { 
         if (start == x.length) {
             return;
         }
         // find the smallest item
     		int smallestIndex = findSmallest(x, start);
         // move it to the front
         swap(x, start, smallestIndex);
         sort(x, start + 1);
      }
  
    	/** Swap item a with b */
    	public static void swap(String[] x, int a, int b) {
          String temp = x[a];
          x[a] = x[b];
          x[b] = temp;
  		}
    
      /** Returns the smallest string in x. */
      public static int findSmallest(String[] x, int start) {
          int smallestIndex = start;
          for (int i = start; i < x.length; i += 1) {
              int cmp = x[i].compareTo(x[smallestIndex]);
              if (cmp < 0) {
                  smallestIndex = i;
              }
          }
          return smallestIndex;
      }
  }
  ```

  ```java
  import org.junit.Test;
  import static org.junit.Assert.*;
  
  /* TestSort Class */
  public class TestSort {
      ...
      /** Test the Sort.findSmallest method. */
      @Test
      public void testFindSmallest() {
          String[] input = {"i", "have", "an", "egg"};
          int expected = 2;
  
          int actual = Sort.findSmallest(input, 0);
          // org.junit.Assert.assertEquals(expected, actual);   
        	assertEquals(expected, actual); 
  
          String[] input2 = {"there", "are", "many", "pigs"};
          int expected2 = 2;
  
          int actual2 = Sort.findSmallest(input2, 2);
          // org.junit.Assert.assertEquals(expected2, actual2);
        	assertEquals(expected2, actual2);
      }
    
      /** Test the Sort.swap method. */
    	@Test
      public void testSwap() {
          String[] input = {"i", "have", "an", "egg"};
          int a = 0;
          int b = 2;
          String[] expected = {"an", "have", "i", "egg"};
  
          Sort.swap(input, a, b);
          // org.junit.Assert.assertArrayEquals(expected, input);
        	assertArrayEquals(expected, input);
      }
  }
  ```



# 4. Inheritance 

## 4.1 Intro and Interfaces

- **Method Overloading:** Java allows multiple methods with same name, but different parameters. 

  ```java
  public static String longest(SLList<String> list)
  public static String longest(AList<String> list)
  ```

  - When you call `WordUtils.longest`, Java knows which one to run according to what kind of parameter you supply it. If you supply it with an AList, it will call the AList method. Same with an SLList.

- **Interface:** is a specification of waht a List is able to do (methods and parameters), not how to do. 

  - Step 1: 

  ```java
  public interface List61B<T> {
      public voif addLast(T x);
      public T getLast();
      public T get(int i);
      public int size();
      public T removeLast();
      public void insert(T x, int position);
      public void addFirst(T x);
      public T getFirst();
  }
  ```

  - Step 2: use the keyword `implements`

  ```java
  public class AList<T> implements List61B<T> {
      ...
      public void addLast(T x) {
          ...
      }
  }
  ```

- **Overriding and Overloading:** 

  - Override: a subclass has a method with the exact same signature as in the superclass

    ```java
    public interface Animal {
    	public void makeNoise();
    }
    
    /** Pig overrides makeNoise() */
    public class Pig implements Animal {
    	public void makeNoise() {
    		System.out.print("oink");
    	}
    }
    ```

  - Overload: a subclass has a method with the same name but different signatures as in the superclass

    ```java
    /** makeNoise is overloaded */
    public class Dog implements Animal {
    	public void makeNoise(Dog x) {
    		...
    	}
    }
    
    /** absis overloaded */
    public class Math {
      public int abs(int a)
      public double abs(double a)
    }
    ```

  - use `@Override` tag at the top for all methods that been overrided. 









# n Examples

















